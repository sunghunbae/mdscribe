{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Install","text":"<p>MDScribe is a set of python libraries and command-line scripts to make  setting up the molecular dynamics simulations easier for Desmond, OpenMM, and Amber.</p> <pre><code>$ pip install mdscribe\n</code></pre>"},{"location":"desmond.html","title":"Desmond","text":""},{"location":"desmond.html#usage","title":"Usage","text":"<pre><code>from mdscribe.desmond import Multisim\n\n# read template .msj and .cfg\nmd_msj = Multisim(template=\"desmond-md.msj\")\nmd_cfg = Multisim(template=\"desmond-md.cfg\")\n\nwith open(msj_file,\"w\") as msj:\n    # modify desmond msj template\n    md_msj.dot.simulate[-1].cfg_file = cfg_file_basename\n\n    # Setting up restraints using the restraints keyword:\n    # https://www.schrodinger.com/kb/332119\n    if args.posres_force &gt; 0.0:\n        # print the restraints in the multisim log file\n        md_msj.dot.simulate[-1].print_restraint = 'true'\n\n        # add the new terms defined in \"restraints.new\" to existing restraints.\n        # The default is restraints.existing = ignore which will \n        # delete existing terms before adding any new ones.\n        # md_msj.dot.simulate[-1].restraints.existing = 'retain'\n\n        md_msj.dot.simulate[-1].restraints.new = [\n            {\n                'name'              : 'posre_harm',\n                'atoms'             : [ f'\"{args.posres}\"' ],\n                'force_constants'   : [ args.posres_force, ] * 3,\n            }\n            ]\n        # force constants in the x, y, and z direction\n\n    # write to a .msj file\n    md_msj.write(msj)\n\nwith open(cfg_file,\"w\") as cfg:\n    # modify desmond cfg template\n    md_cfg.dot.randomize_velocity.seed = random.randint(1000, 9999)\n    md_cfg.dot.time = total_simulation_time\n    md_cfg.dot.temperature = t_schedule\n    md_cfg.dot.trajectory.interval = args.interval\n\n    # write to a .cfg file\n    md_cfg.write(cfg)\n</code></pre>"},{"location":"desmond.html#metadynamics","title":"Metadynamics","text":""},{"location":"desmond.html#collective-variable-types","title":"Collective variable types","text":"type Description Default Width Wall Floor Atom sites dist Distance 0.05 \u00c5 yes yes 2 angle Angle 2.5\u00b0 yes yes 3 dihedral Dihedral 5.0\u00b0 no no 4 rgyr Radius of gyration 0.1 \u00c5 no no 1 rgyr_mass Mass-weighted radius of gyration 0.1 \u00c5 no no 1 rmsd RMSD from aligned starting structure 0.1 \u00c5 no no 1 rmsd_symm Symmetry aware RMSD 0.1 \u00c5 no no 1 zdist Distance along the z axis 0.05 \u00c5 yes yes 1 zdist0 Absolute distance along the z axis 0.1 \u00c5 yes yes 1 whim1 WHIM1 - first principal moment [35] 0.5 \u00c52 no no 1 whim2 WHIM2 - second principal moment [35] 0.25 \u00c52 no no 1"},{"location":"desmond.html#choice-of-the-bias-factor-ktemp","title":"Choice of the bias factor (kTemp)","text":"<p>In well-tempered metadynamics, the height of the deployed Gaussians are rescaled (decreased) during simulation time by: omega_0 * exp(-V/(kB * \u0394T)) Where omega_0 is the initial hill height, V is the bias potential and the denominator in the exponential, kB * \u0394T, is the bias factor (kTemp). During well-tempered metadynamics, the dynamics of the system are effectively accelerated  (without heating up the system) up to T + \u0394T, where T is the chosen MD simulation temperature.  The choice of the bias factor value is guided by the highest barrier in the simulation system  which the well-tempered metadynamics run should overcome. Here are some suggestions,  assuming that the initial hill height \u03c90 (height parameter in the Metadynamics panel) has been set to 0.3 kcal/mol:</p> Max. barrier height (kcal/mol) kTemp (kcal/mol) 3 1.7 6 3.4 10 5.6 15 8.4 20 11.2"},{"location":"desmond.html#examples","title":"Examples","text":"<pre><code>distance:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = dist\n        wall = 40\n        floor = 10\n        width = 0.05\n        }\n    ]\n\ndihedral:\n    cv = [\n        {atom = [404 406 407 415 ]\n        type = dihedral\n        width = 5.0\n        }\n        {atom = [406 407 415 417 ]\n        type = dihedral\n        width = 5.0\n        }\n    ]\n\nzdist(membrane):\n    cv = [\n        {atom = [\"res. UNK\"]\n        type = zdist\n        width = 0.05\n        wall = 20\n        floor = 5\n        }\n        ]\n\nrmsd:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = rmsd\n        width = 0.1\n        }\n    ]\n</code></pre>"},{"location":"desmond.html#extending-simulations","title":"Extending Simulations","text":"<p>See https://www.schrodinger.com/kb/788642 for extending metadynamics simulation.</p>"},{"location":"desmond.html#command-line-interface-cli","title":"Command-Line Interface (CLI)","text":"<p><code>desmond.Multisim</code> class are used to build below CLI.</p> Command-line interface Description <code>mdinfo</code> Display a running Desmond MD simulation information in the Amber-style <code>batch-desmond-setup</code> Setup/parametrize Desmond MD simulations <code>batch-desmond-min</code> Run Desmond energy minimizations <code>batch-desmond-md</code> Run Desmond MD simulations <code>batch-desmond-metad</code> Run metadynamics MD simulations <code>batch-desmond-pli</code> Analyze protein-ligand interactions <code>batch-desmond-extend</code> Extend Desmond MD simulations <code>batch-desmond-report</code> Generate reports for Desmond MD simulations <code>batch-desmond-dihedral</code> Analyze dihedral angles from Desmond MD trajectories <code>batch-desmond-ligrmsd</code> Analyze ligand rmsd from Desmond MD trajectories <code>batch-desmond-rg</code> Analyze radius of gyration from Desmond MD trajectories <p>For more helps, <code>$ command --help</code>.</p>"},{"location":"desmond.html#mdscribe.desmond.cli","title":"<code>mdscribe.desmond.cli</code>","text":""},{"location":"desmond.html#mdscribe.desmond.cli.SCHRODINGER","title":"<code>SCHRODINGER = os.environ['SCHRODINGER']</code>  <code>module-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.cli.USER","title":"<code>USER = os.environ['USER']</code>  <code>module-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.cli.multisim","title":"<code>multisim = '{}/utilities/multisim'.format(SCHRODINGER)</code>  <code>module-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.cli.schrodinger_hosts","title":"<code>schrodinger_hosts = '{}/schrodinger.hosts'.format(SCHRODINGER)</code>  <code>module-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.cli.schrodinger_run","title":"<code>schrodinger_run = '{}/run'.format(SCHRODINGER)</code>  <code>module-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.cli.script_path","title":"<code>script_path = files('mdscribe.desmond.script')</code>  <code>module-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.cli.batch_dihedral","title":"<code>batch_dihedral()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_dihedral() -&gt; None:\n    subprocess.run([schrodinger_run, script_path.joinpath('batch-desmond-dihedral.py')])\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_distance","title":"<code>batch_distance()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_distance() -&gt; None:\n    subprocess.run([schrodinger_run, script_path.joinpath('batch-desmond-distance.py')])\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_extend","title":"<code>batch_extend()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_extend() -&gt; None:\n    # *-in.cms\n    # read .cfg file and get last_time\n    # /home/shbae/local/schrodinger2020-2/desmond \\\n    # -JOBNAME ${j} -HOST localhost -gpu -restore ${j}.cpt -in ${j}-in.cms -cfg mdsim.last_time=500000 -WAIT\n    raise NotImplementedError\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_ligrmsd","title":"<code>batch_ligrmsd()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_ligrmsd() -&gt; None:\n    subprocess.run([schrodinger_run, script_path.joinpath('batch-desmond-ligrmsd.py')])\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_md","title":"<code>batch_md()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_md():\n    md_msj = desmond.Multisim(template=\"desmond-md.msj\")\n    md_cfg = desmond.Multisim(template=\"desmond-md.cfg\")\n\n    parser = argparse.ArgumentParser(description=\"batch gdesmond md jobs\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('-g', dest=\"gpu_device\", type=int, default=0, \n                        metavar=\"gpu_device\", help=\"gpu device id\")\n    parser.add_argument('-T', dest=\"temp\", nargs=\"+\", type=float, default=[300.0,], \n                        metavar=\"temperature\", help=\"temperature in K\")\n    parser.add_argument('-R', dest=\"ramp\", nargs=\"+\", type=float, default=[10.0,],\n                        metavar=\"tempramp\", help=\"heat and cool ramps in ps/K\")\n    parser.add_argument('-t', dest=\"simulation_time\", nargs=\"+\", type=float, default=[100.0,],\n                        metavar=\"simulation_time\", help=\"simulation time in ns\")\n    parser.add_argument('-i', dest=\"interval\", type=float, default=100.0,\n                        metavar=\"interval\", help=\"frame interval in ps\")\n    parser.add_argument('--posres', dest=\"posres\", default=\"res. UNK\",\n                        metavar=\"posres\", help=\"ASL for positional restraints during prod. sim.\")\n    parser.add_argument('--posres-force', dest=\"posres_force\", type=float, default=0.0,\n                        metavar=\"posres_force\", help=\"positional restraints force constant (kcal/mol/A**2)\")\n    parser.add_argument('-p', dest=\"prefix\", default=\"r\", help=\"directory prefix\")\n    parser.add_argument('-s', dest=\"start\", type=int, default=1, help=\"directory start\")\n    parser.add_argument('-r', dest=\"repeat\", type=int, default=1, help=\"number of repeats\")\n    parser.add_argument('-j', dest=\"job_file\", default=\"desmond_md_job_1.sh\", help=\"job filename\")\n    parser.add_argument('cms', nargs=\"+\", help=\"desmond cms file\")\n    args = parser.parse_args()\n\n    try:\n        cms_files = [os.path.abspath(f) for f in args.cms]\n        assert(len(cms_files) &gt; 0)\n    except:\n        print(\".cms file(s) not found\")\n        sys.exit(0)\n\n    opt  = '-HOST localhost -maxjob 1 -cpu 1 -mode umbrella '\n    opt += '-set stage[1].set_family.md.jlaunch_opt=[\"-gpu\"] -lic \"DESMOND_GPGPU:16\"'\n\n    job_file = args.job_file\n    while os.path.exists(job_file):\n        splited = job_file.replace(\".sh\",\"\").split(\"_\")\n        splited[-1] = str(int(splited[-1]) + 1)\n        job_file = \"_\".join(splited) + \".sh\"\n\n    if len(args.temp) &gt; 1:\n        try:\n            assert len(args.temp) == len(args.simulation_time)\n            assert len(args.temp) == (len(args.ramp) + 1)\n        except:\n            print(\"For a variable temperature simulaton, the number of temperatures and simulation times \")\n            print(\"should match and temperature ramp(s) (ps/K) should be given between temperatures.\")\n            print(\"Please check -T, -t and -R options\")\n            sys.exit(0)\n    else:\n        args.ramp = [] # not used\n\n    # Note: if not specified, \n    # all times are in the unit of ps and \n    # energy is in the unit of kcal/mol.\n\n    with open(\"README\",\"a\") as readme, open(job_file,\"w\") as job:\n        print(f\"Job file = {job_file}\")\n\n        dirs = [ f\"{args.prefix}{n:02d}\" for n in range(args.start, args.start+args.repeat) ]\n\n        t_schedule = [ [ args.temp[0], 0.0 ], ]\n\n        if len(args.temp) &gt; 1 :\n\n            elapsed = 0\n            prev_temp = args.temp[0]\n            idx = 0\n\n            for (temp,simulation_time) in zip(args.temp, args.simulation_time):\n\n\n                deltaT = abs(temp - prev_temp)\n\n                if deltaT &gt; 0.001: # ramp\n                    elapsed += args.ramp[idx] * deltaT # ramp: ps/K\n                    t_schedule.append([temp, elapsed])\n                    idx += 1\n\n                elapsed += simulation_time * 1000. # ns -&gt; ps\n                t_schedule.append([temp, elapsed]) # ns -&gt; ps\n                prev_temp = temp\n            total_simulation_time = elapsed # ps\n        else:\n            total_simulation_time = sum(args.simulation_time) * 1000.0 # ps\n\n        if not args.interval:\n            # args.simulation_time in ns and args.interval in ps\n            # default: make 1000 frames\n            args.interval = total_simulation_time / 1000.\n\n        cmd_echo = \"\"\n        for argv in sys.argv:\n            if cmd_echo:\n                cmd_echo += \" \"\n            if \" \" in argv:\n                cmd_echo += f'\"{argv}\"'\n            else:\n                cmd_echo += f'{argv}'\n        readme.write(f\"{cmd_echo}\\n\\n\")\n        readme.write(f\"GPU device              = {args.gpu_device}\\n\")\n        readme.write(f\"Temperature (K)         = {args.temp}\\n\")\n        readme.write(f\"Temperature Ramp (ps/K) = {args.ramp}\\n\")\n        readme.write(f\"Simulation Time (ns)    = {args.simulation_time}\\n\")\n        readme.write(f\"Temperature schedule    = {str(t_schedule)}\\n\")\n        readme.write(f\"Total Sim. Time (ns)    = {total_simulation_time/1000.0}\\n\")\n        readme.write(f\"Trajectory interval(ps) = {args.interval}\\n\")\n        readme.write(f\"Repeat                  = {args.repeat}\\n\")\n        readme.write( \"Directory               = %s\\n\" % \" \".join(dirs))\n        readme.write(f\"Jobfile                 = {job_file}\\n\\n\")\n\n        for i, infile in enumerate(cms_files):\n            info = f\"[{i+1:02d}] {infile}\"\n            print(info)\n            readme.write(info+\"\\n\")\n        readme.write(\"\\n\\n\")\n\n        job.write(f'export CUDA_VISIBLE_DEVICES=\"{args.gpu_device}\"\\n\\n')\n\n        for n in range(args.start, args.start+args.repeat): \n            outdir = f\"{args.prefix}{n:02d}\"\n            outdir_abspath = os.path.abspath(outdir)\n            job.write(f\"cd {outdir_abspath}/\\n\\n\")\n            if not os.path.exists(outdir):\n                os.makedirs(outdir)\n            msj_file = f\"{outdir}/desmond_md_job_{n:02d}.msj\"\n            cfg_file = f\"{outdir}/desmond_md_job_{n:02d}.cfg\"\n            cfg_file_basename= os.path.basename(cfg_file)\n\n            with open(msj_file,\"w\") as msj:\n                # modify desmond msj template\n                md_msj.dot.simulate[-1].cfg_file = cfg_file_basename\n\n                # Setting up restraints using the restraints keyword:\n                # https://www.schrodinger.com/kb/332119\n                if args.posres_force &gt; 0.0:\n                    # print the restraints in the multisim log file\n                    md_msj.dot.simulate[-1].print_restraint = 'true'\n\n                    # add the new terms defined in \"restraints.new\" to existing restraints.\n                    # The default is restraints.existing = ignore which will \n                    # delete existing terms before adding any new ones.\n                    # md_msj.dot.simulate[-1].restraints.existing = 'retain'\n\n                    md_msj.dot.simulate[-1].restraints.new = [\n                        {\n                            'name'              : 'posre_harm',\n                            'atoms'             : [ f'\"{args.posres}\"' ],\n                            'force_constants'   : [ args.posres_force, ] * 3,\n                        }\n                        ]\n                    # force constants in the x, y, and z direction\n\n                md_msj.write(msj)\n\n            with open(cfg_file,\"w\") as cfg:\n                # modify desmond cfg template\n                md_cfg.dot.randomize_velocity.seed = random.randint(1000, 9999)\n                md_cfg.dot.time = total_simulation_time\n                md_cfg.dot.temperature = t_schedule\n                md_cfg.dot.trajectory.interval = args.interval\n                md_cfg.write(cfg)\n\n            for infile in cms_files:\n                prefix_ = re.sub(r'desmond_setup[-_]','', os.path.basename(infile))\n                prefix  = prefix_.replace(\"-out.cms\",\"\")\n\n                job_name = f\"desmond_md_job_{n:02d}_{prefix}\"\n                job.write('if [ ! -f {}/{} ]\\n'.format( outdir_abspath, f\"{job_name}-out.cms\",))\n                job.write('then\\n')\n                job.write('{} -JOBNAME {} -m {} -c {} -description \"{}\" {} {} -o {} -WAIT\\n'.format(\n                    multisim, \n                    job_name, \n                    os.path.basename(msj_file),\n                    os.path.basename(cfg_file),\n                    \"GPU desmond MD\",\n                    opt,\n                    os.path.join(\"..\",infile),\n                    f\"{job_name}-out.cms\",\n                ))\n                job.write('fi\\n\\n')\n\n    os.chmod(job_file, 0o777)\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_metad","title":"<code>batch_metad()</code>","text":"<p>Metadynamics Simulations.</p> Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_metad():\n    \"\"\"Metadynamics Simulations.\n    \"\"\"\n\n    metad_msj = desmond.Multisim(template=\"desmond-metad.msj\")\n    metad_cfg = desmond.Multisim(template=\"desmond-metad.cfg\")\n\n    opt = '-HOST localhost -maxjob 1 -cpu 1 -mode umbrella -lic \"DESMOND_GPGPU:16\" '\n    opt += '-description \"metadynamics\"'\n\n    parser = argparse.ArgumentParser(description=\"batch gdesmond metadynamics jobs\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument('--meta-height', dest=\"meta_height\", type=float, default=0.03, help=\"Height of the repulsive Gaussian potential in kcal/mol (0.03)\")\n    parser.add_argument('--meta-interval', dest=\"meta_interval\", type=float, default=0.09, help=\"Interval in ps at which Gaussian potentials are added (0.09)\")\n    parser.add_argument('--meta-first', dest=\"meta_first\", type=float, default=0.0, help=\"Time in ps at which the Gaussian potentials are first added (0)\")\n    parser.add_argument('--meta-last', dest=\"meta_last\", type=float, default=-1.0, help=\"Time in ps at which the Gaussian potentials are last added (simulation time)\")\n    parser.add_argument('--meta-kTemp', dest=\"meta_kTemp\", type=float, default=2.4, help=\"Perform the well-tempered metadynamics (2.4)\")\n    parser.add_argument('--cv-dist', dest='cv_dist', nargs=4, action='append', default=[], help=\"atom1 atom2 width(0.05) wall\")\n    parser.add_argument('--cv-angle', dest='cv_angle', nargs=4, action='append', default=[], help=\"atom1 atom2 atom3 width(2.5)\")\n    parser.add_argument('--cv-dihedral', dest='cv_dihedral', nargs=5, action='append', default=[], help=\"atom1 atom2 atom3 atom4 width(5.0)\")\n    parser.add_argument('--cv-rgyr', dest='cv_rgyr', nargs=2, action='append', default=[], help=\"atom width(0.1)\")\n    parser.add_argument('--cv-rgyr-mass', dest='cv_rgyr_mass', nargs=2, action='append', default=[], help=\"atom width(0.1)\")\n    parser.add_argument('--cv-rmsd', dest='cv_rmsd', nargs=2, action='append', default=[], help=\"atom width(0.1)\")\n    parser.add_argument('--cv-rmsd-symm', dest='cv_rmsd_symm', nargs=2, action='append', default=[], help=\"atom width(0.1)\")\n    parser.add_argument('--cv-zdist', dest='cv_zdist', nargs=3, action='append', default=[], help=\"atom width wall(0.05)\")\n    parser.add_argument('--cv-zdist0', dest='cv_zdist0', nargs=3, action='append', default=[], help=\"atom width wall(0.1)\")\n    parser.add_argument('-g', dest=\"gpu_device\", type=int, default=0, help=\"gpu device id\")\n    parser.add_argument('-T', dest=\"temperature\", type=float, default=300.0, help=\"temperature in Kelvin\")\n    parser.add_argument('-t', dest=\"simulation_time\", type=float, default=40.0, help=\"simulation time in ns\")\n    parser.add_argument('-i', dest=\"interval\", type=float, default=40.0, help=\"frame interval in ps\")\n    parser.add_argument('-p', dest=\"prefix\", type=str, default=\"m\", help=\"directory prefix\")\n    parser.add_argument('-s', dest=\"start\", type=int, default=1, help=\"directory start\")\n    parser.add_argument('-r', dest=\"repeat\", type=int, default=1, help=\"number of repeats\")\n    parser.add_argument('-j', dest=\"job_file\", type=str, default=\"desmond_metadynamics_job_1.sh\", help=\"job filename\")\n    parser.add_argument('cms', nargs=\"+\", help=\"desmond cms file\")\n    args = parser.parse_args()\n\n    try:\n        cms_files = [os.path.abspath(f) for f in args.cms]\n        assert(len(cms_files) &gt; 0)\n    except:\n        print(\".cms file(s) not found\")\n        sys.exit(0)\n\n    if not args.interval:\n        args.interval = args.simulation_time # it will save 1000 frames\n\n    job_file = args.job_file\n    while os.path.exists(job_file):\n        splited = job_file.replace(\".sh\",\"\").split(\"_\")\n        splited[-1] = str(int(splited[-1]) + 1)\n        job_file = \"_\".join(splited) + \".sh\"\n\n\n    with open(\"README\",\"a\") as readme, open(job_file,\"w\") as job:\n        print(\"\\n\" + job_file + \"\\n\")\n        outdir_nums = list(range(args.start, args.start+args.repeat))\n        outdirs = [f\"{args.prefix}{num:02d}\" for num in outdir_nums]\n        cmd_echo = \"\"\n        for argv in sys.argv:\n            if cmd_echo:\n                cmd_echo += \" \"\n            if \" \" in argv:\n                cmd_echo += f'\"{argv}\"'\n            else:\n                cmd_echo += f'{argv}'\n        readme.write(f\"{cmd_echo}\\n\\n\")\n        readme.write(f\"GPU device              = {args.gpu_device}\\n\")\n        readme.write(f\"Temperature (K)         = {args.temperature}\\n\")\n        readme.write(f\"Simulation Time (ns)    = {args.simulation_time}\\n\")\n        readme.write(f\"Trajectory interval(ps) = {args.interval}\\n\")\n        readme.write(f\"Repeat                  = {args.repeat}\\n\")\n        readme.write( \"Directory               = %s\\n\" % \" \".join(outdirs))\n        readme.write(f\"Jobfile                 = {job_file}\\n\\n\")\n\n        job.write(f'export CUDA_VISIBLE_DEVICES=\"{args.gpu_device}\"\\n\\n')\n\n        for i, infile in enumerate(cms_files):\n            info = f\"[{i+1}] {infile}\"\n            print(info)\n            readme.write(info+\"\\n\")\n        print()\n        readme.write(\"\\n\")\n\n        for (num, outdir) in zip(outdir_nums, outdirs):\n            outdir_abspath = os.path.abspath(outdir)\n            job.write(f\"cd {outdir_abspath}/\\n\\n\")\n            if not os.path.exists(outdir):\n                os.makedirs(outdir)\n            cfg_file = f\"{outdir}/desmond_metadynamics_job_{num:02d}.cfg\"\n            msj_file = f\"{outdir}/desmond_metadynamics_job_{num:02d}.msj\"\n            cfg_file_basename= os.path.basename(cfg_file)\n\n            with open(cfg_file,\"w\") as cfg, open(msj_file,\"w\") as msj:\n                metad_cfg.dot.randomize_velocity.seed = str(random.randint(1000,9999))\n                metad_cfg.dot.time = str(args.simulation_time*1000.0)\n                metad_cfg.dot.trajectory.interval = str(args.interval)\n                metad_cfg.dot.temperature = f\"[ [{args.temperature} 0] ]\"\n                metad_cfg.write(cfg)\n\n                metad_msj.dot.simulate[-1].cfg_file = cfg_file_basename\n\n                # metadynamics\n                cv_list = []\n\n\n                for atom1, atom2, width, wall in args.cv_dist:\n                    cv = copy.deepcopy(metad_msj.dot.simulate[-1].meta.cv[0])\n                    atom1 = index_or_asl(atom1)\n                    atom2 = index_or_asl(atom2)\n                    cv.atom = f'[{atom1} {atom2}]'\n                    cv.type = 'dist'\n                    cv.width = str(width)\n                    if not wall.startswith('-'):\n                        cv.wall = str(wall)\n                    cv_list.append(cv)\n\n                for atom1, atom2, atom3, width in args.cv_angle:\n                    cv = copy.deepcopy(metad_msj.dot.simulate[-1].meta.cv[0])\n                    atom1 = index_or_asl(atom1)\n                    atom2 = index_or_asl(atom2)\n                    atom3 = index_or_asl(atom3)\n                    cv.atom = f'[{atom1} {atom2} {atom3}]'\n                    cv.type = 'angle'\n                    cv.width = str(width)\n                    cv_list.append(cv)\n\n                for atom1, atom2, atom3, atom4, width in args.cv_dihedral:\n                    cv = copy.deepcopy(metad_msj.dot.simulate[-1].meta.cv[0])\n                    atom1 = index_or_asl(atom1)\n                    atom2 = index_or_asl(atom2)\n                    atom3 = index_or_asl(atom3)\n                    atom4 = index_or_asl(atom4)\n                    cv.atom = f'[{atom1} {atom2} {atom3} {atom4}]'\n                    cv.type = 'dihedral'\n                    cv.width = str(width)\n                    cv_list.append(cv)\n\n                for atom1, width in args.cv_rmsd:\n                    cv = copy.deepcopy(metad_msj.dot.simulate[-1].meta.cv[0])\n                    atom1 = index_or_asl(atom1)\n                    cv.atom = f'[{atom1}]'\n                    cv.type = 'rmsd'\n                    cv.width = str(width)\n                    cv_list.append(cv)\n\n                for atom1, width in args.cv_rmsd_symm:\n                    cv = copy.deepcopy(metad_msj.dot.simulate[-1].meta.cv[0])\n                    atom1 = index_or_asl(atom1)\n                    cv.atom = f'[{atom1}]'\n                    cv.type = 'rmsd_symm'\n                    cv.width = str(width)\n                    cv_list.append(cv)\n\n                for atom1, width in args.cv_rgyr:\n                    cv = copy.deepcopy(metad_msj.dot.simulate[-1].meta.cv[0])\n                    atom1 = index_or_asl(atom1)\n                    cv.atom = f'[{atom1}]'\n                    cv.type = 'rgyr'\n                    cv.width = str(width)\n                    cv_list.append(cv)\n\n                for atom1, width in args.cv_rgyr_mass:\n                    cv = copy.deepcopy(metad_msj.dot.simulate[-1].meta.cv[0])\n                    atom1 = index_or_asl(atom1)\n                    cv.atom = f'[{atom1}]'\n                    cv.type = 'rgyr_mass'\n                    cv.width = str(width)\n                    cv_list.append(cv)\n\n                for atom1, width, wall in args.cv_zdist:\n                    cv = copy.deepcopy(metad_msj.dot.simulate[-1].meta.cv[0])\n                    atom1 = index_or_asl(atom1)\n                    cv.atom = f'[{atom1}]'\n                    cv.type = 'zdist'\n                    cv.width = str(width)\n                    if not wall.startswith('-'):\n                        cv.wall = str(wall)\n                    cv_list.append(cv)\n\n                for atom1, width, wall in args.cv_zdist0:\n                    cv = copy.deepcopy(metad_msj.dot.simulate[-1].meta.cv[0])\n                    atom1 = index_or_asl(atom1)\n                    cv.atom = f'[{atom1}]'\n                    cv.type = 'zdist0'\n                    cv.width = str(width)\n                    if not wall.startswith('-'):\n                        cv.wall = str(wall)\n                    cv_list.append(cv)\n\n                metad_msj.dot.simulate[-1].meta.cv = cv_list\n                metad_msj.dot.simulate[-1].meta.height = str(args.meta_height)\n                metad_msj.dot.simulate[-1].meta.interval = str(args.meta_interval)\n                metad_msj.dot.simulate[-1].meta.first = str(args.meta_first)\n\n                if args.meta_last &gt; 0.0:\n                    metad_msj.dot.simulate[-1].meta.last = str(args.meta_last)\n\n                # well-tempered metadynamics\n                if args.meta_kTemp &gt; 0.0:\n                    metad_msj.dot.simulate[-1].meta.kTemp = str(args.meta_kTemp)\n\n                metad_msj.write(msj)\n\n            # append to job file\n            for infile in cms_files:\n                prefix_ = re.sub(r'desmond_setup[-_]','', os.path.basename(infile))\n                prefix  = prefix_.replace(\"-out.cms\",\"\")\n                job_name = f\"desmond_metadynamics_job_{num:02d}_{prefix}\"\n                job.write('{} -JOBNAME {} -m {} -c {} {} {} -o {} -WAIT\\n\\n'.format(\n                    multisim, \n                    job_name,\n                    os.path.basename(msj_file),\n                    os.path.basename(cfg_file),\n                    opt,\n                    infile,\n                    f\"{job_name}-out.cms\",\n                ))\n\n    os.chmod(job_file, 0o777)\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_min","title":"<code>batch_min()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_min():\n    min_msj = desmond.Multisim(template=\"desmond-min.msj\")\n    min_cfg = desmond.Multisim(template=\"desmond-min.cfg\")\n\n    opt = '-HOST localhost -maxjob 1 -cpu 1 -mode umbrella '\n    opt += '-lic \"DESMOND_GPGPU:16\" '\n    opt += '-description \"minimization\"'\n\n    parser = argparse.ArgumentParser(description=\"batch gdesmond minimization jobs\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('-g', dest=\"gpu_device\", type=int, default=0, \n                        help=\"gpu device id\")\n    parser.add_argument('-t', dest=\"simulation_time\", type=float, default=100.0, \n                        help=\"simulation time in ps\")\n    parser.add_argument('-p', dest=\"prefix\", type=str, default=\"r\", \n                        help=\"directory prefix\")\n    parser.add_argument('-s', dest=\"start\", type=int, default=1, \n                        help=\"directory start\")\n    parser.add_argument('-r', dest=\"repeat\", type=int, default=1, \n                        help=\"number of repeats\")\n    parser.add_argument('-j', dest=\"job_file\", type=str, default=\"desmond_min_job_1.sh\", \n                        help=\"job filename\")\n    parser.add_argument('cms', nargs=\"+\", help=\"desmond cms file\")\n    args = parser.parse_args()\n\n    try:\n        cms_files = [os.path.abspath(f) for f in args.cms]\n        assert(len(cms_files) &gt; 0)\n    except:\n        print(\".cms file(s) not found\")\n        sys.exit(0)\n\n\n    job_file = args.job_file\n    while os.path.exists(job_file):\n        splited = job_file.replace(\".sh\",\"\").split(\"_\")\n        splited[-1] = str(int(splited[-1]) + 1)\n        job_file = \"_\".join(splited) + \".sh\"\n\n\n    with open(\"README\",\"a\") as readme, open(job_file,\"w\") as job:\n        print(\"\\n\" + job_file + \"\\n\")\n        outdir_nums = list(range(args.start, args.start+args.repeat))\n        outdirs = [f\"{args.prefix}{num:02d}\" for num in outdir_nums]\n        cmd_echo = \"\"\n        for argv in sys.argv:\n            if cmd_echo:\n                cmd_echo += \" \"\n            if \" \" in argv:\n                cmd_echo += f'\"{argv}\"'\n            else:\n                cmd_echo += f'{argv}'\n        readme.write(f\"{cmd_echo}\\n\\n\")\n        readme.write(f\"GPU device              = {args.gpu_device}\\n\")\n        readme.write(f\"Simulation Time (ns)    = {args.simulation_time}\\n\")\n        readme.write(f\"Repeat                  = {args.repeat}\\n\")\n        readme.write( \"Directory               = %s\\n\" % \" \".join(outdirs))\n        readme.write(f\"Jobfile                 = {job_file}\\n\\n\")\n\n        job.write(f'export CUDA_VISIBLE_DEVICES=\"{args.gpu_device}\"\\n\\n')\n\n        for i, infile in enumerate(cms_files):\n            info = f\"[{i+1}] {infile}\"\n            print(info)\n            readme.write(info+\"\\n\")\n        print()\n        readme.write(\"\\n\")\n\n        for (num, outdir) in zip(outdir_nums, outdirs):\n            outdir_abspath = os.path.abspath(outdir)\n            job.write(f\"cd {outdir_abspath}/\\n\\n\")\n            if not os.path.exists(outdir):\n                os.makedirs(outdir)\n            cfg_file = f\"{outdir}/desmond_min_job_{num:02d}.cfg\"\n            msj_file = f\"{outdir}/desmond_min_job_{num:02d}.msj\"\n            cfg_file_basename= os.path.basename(cfg_file)\n\n            with open(cfg_file,\"w\") as cfg, open(msj_file,\"w\") as msj:\n                min_cfg.dot.randomize_velocity.seed = str(random.randint(1000,9999))\n                min_cfg.dot.time = str(args.simulation_time) # (ps)\n                min_cfg.write(cfg)\n\n                min_msj.dot.simulate.cfg_file = cfg_file_basename\n                min_msj.write(msj)\n\n            # append to job file\n            for infile in cms_files:\n                prefix_ = re.sub(r'desmond_setup[-_]','', os.path.basename(infile))\n                prefix  = prefix_.replace(\"-out.cms\",\"\")\n                job_name = f\"desmond_min_job_{num:02d}_{prefix}\"\n                job.write('{} -JOBNAME {} -m {} -c {} {} {} -o {} -WAIT\\n\\n'.format(\n                    multisim, \n                    job_name,\n                    os.path.basename(msj_file),\n                    os.path.basename(cfg_file),\n                    opt,\n                    infile,\n                    f\"{job_name}-out.cms\",\n                ))\n\n    os.chmod(job_file, 0o777)\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_pli","title":"<code>batch_pli()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_pli():\n    teststring =\"\"\"Keywords = [\n    {RMSD = {\n        ASL = \"((mol. 1 and backbone) and not (atom.ele H) and not (mol. 2))\"\n        Frame = 0\n        Panel = pl_interact_survey\n        Result = [0.0 1.161 1.286 1.331 1.176 1.195 ]\n        SelectionType = Backbone\n        Tab = pl_rmsd_tab\n        Type = ASL\n        Unit = Angstrom\n        }\n    }\n    {RMSD = {\n        ASL = \"(mol. 1 and sidechain and not (mol. 2))\"\n        Frame = 0\n        Panel = pl_interact_survey\n        Result = [0.0 1.161 1.286 1.331 1.176 1.195 ]\n        SelectionType = \"Side chains\"\n        Tab = pl_rmsd_tab\n        Type = ASL\n        Unit = Angstrom\n        }\n    }\n    ]\"\"\"\n    # result = expr.parse_string(teststring)\n    # d = result.as_dict()\n    # traverse_dict(d)\n    # dot = DotMap(d)\n    # try:\n    #     assert dot.Keywords[1].RMSD.SelectionType == '\"Side chains\"'\n    #     print(\"ok\")\n    # except:\n    #     print(\"error\")\n\n    parser = argparse.ArgumentParser(description=\"Average Protein-Ligand Interactions\",\n    formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('--out', dest='out', default='mean-PLIF', help=\"output basename\")\n    parser.add_argument('eaf', nargs='+', default=[], help='input -out.eaf filename(s)')\n    args = parser.parse_args()\n\n    if len(args.eaf) == 0:\n        argparse.print_help()\n        sys.exit(0)\n\n    total_num_frames = 0\n    data = {}\n    for filename in args.eaf:\n        (num_frames, HBond, Hydrophobic, Polar, WaterBridge, \n        HalogenBond, LigWat, Metal, PiCat, PiPi) = read_eaf(filename, verbose=False)\n\n        total_num_frames += num_frames\n\n        print(f\"{filename}  {num_frames} frames\")\n\n        for resSeq in HBond:\n            if resSeq in data:\n                data[resSeq]['hbond'] += HBond[resSeq]['count']\n            else:\n                data[resSeq] = {'resName': HBond[resSeq]['resName'], \n                                'hbond': HBond[resSeq]['count'],\n                                'hydrophobic': 0,\n                                'polar': 0,\n                                'waterbridge': 0,\n                                }\n        for resSeq in Hydrophobic:\n            if resSeq in data:\n                data[resSeq]['hydrophobic'] += Hydrophobic[resSeq]['count']\n            else:\n                data[resSeq] = {'resName': Hydrophobic[resSeq]['resName'], \n                                'hbond': 0,\n                                'hydrophobic': Hydrophobic[resSeq]['count'],\n                                'polar': 0,\n                                'waterbridge': 0,\n                                }\n        for resSeq in Polar:\n            if resSeq in data:\n                data[resSeq]['polar'] += Polar[resSeq]['count']\n            else:\n                data[resSeq] = {'resName': Polar[resSeq]['resName'], \n                                'hbond': 0,\n                                'hydrophobic': 0,\n                                'polar': Polar[resSeq]['count'],\n                                'waterbridge': 0,\n                                }\n        for resSeq in WaterBridge:\n            if resSeq in data:\n                data[resSeq]['waterbridge'] += WaterBridge[resSeq]['count']\n            else:\n                data[resSeq] = {'resName': WaterBridge[resSeq]['resName'],\n                                'hbond': 0,\n                                'hydrophobic' : 0,\n                                'polar': 0,\n                                'waterbridge': WaterBridge[resSeq]['count'],\n                                } \n\n    csvdata = {'resid':[], \n            'resSeq':[], \n            'resName':[], \n            'hbond':[], \n            'hydrophobic':[],\n            'polar': [],\n            'waterbridge': [],\n            }\n\n    for resSeq in sorted(data):\n        csvdata['resSeq'].append(resSeq)\n        csvdata['resName'].append(data[resSeq]['resName'])\n        csvdata['resid'].append(f\"{data[resSeq]['resName']}_{resSeq}\")\n        csvdata['hbond'].append(float(data[resSeq]['hbond'])/total_num_frames)\n        csvdata['hydrophobic'].append(float(data[resSeq]['hydrophobic'])/total_num_frames)\n        csvdata['polar'].append(float(data[resSeq]['polar'])/total_num_frames)\n        csvdata['waterbridge'].append(float(data[resSeq]['waterbridge'])/total_num_frames)\n\n    df = pd.DataFrame(csvdata)\n    df.to_csv(args.out + '.csv', index=False, float_format='%.4f')\n    g = df.loc[:, ~df.columns.isin(['resSeq','resName'])].plot.bar(\n        x=\"resid\", \n        stacked=True,\n        title=\"Protein-Ligand Interactions\", \n        xlabel='Residue', \n        ylabel='Fraction of MD trajectory', \n        figsize=(8,3), \n        fontsize=8,\n        )\n    fig = g.get_figure()\n    fig.savefig(args.out + '.pdf', bbox_inches=\"tight\", pad_inches=0.2, dpi=150)\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_report","title":"<code>batch_report()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_report() -&gt; None:\n    subprocess.run([schrodinger_run, script_path.joinpath('batch-desmond-report.py')])\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_rg","title":"<code>batch_rg()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_rg() -&gt; None:\n    subprocess.run([schrodinger_run, script_path.joinpath('batch-desmond-rg.py')])\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.batch_setup","title":"<code>batch_setup()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def batch_setup():\n    setup_msj = desmond.Multisim(template=\"desmond-setup.msj\")\n\n    parser = argparse.ArgumentParser(description=\"batch gdesmond md system setup\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('-c','--conc', dest=\"conc\", type=float, default=0.15, help=\"salt concentration in M\")\n    parser.add_argument('-d','--dist', dest=\"dist\", type=float, default=10.0, help=\"buffer distance in A\")\n    parser.add_argument('-l','--lipid',  dest=\"lipid\", default=\"\", help=\"lipid bilayer\")\n    parser.add_argument('--cpp', dest=\"cpp\", default=False, action=\"store_true\", help=\"CPP simulation setup\")\n    parser.add_argument('-s','--solvent',  dest=\"solvent\", default=\"TIP3P\", help=\"solvent model\")\n    parser.add_argument('-i','--counterion',  dest=\"counterion\", default=\"Na\", help=\"neutralizing ion\")\n    parser.add_argument('-n','--negative', dest=\"neg\", default=\"Cl\", help=\"negative salt ion\")\n    parser.add_argument('-p','--positive', dest=\"pos\", default=\"Na\", help=\"positive salt ion\")\n    parser.add_argument('-f','--forcefield', dest=\"forcefield\", default=\"S-OPLS\", help=\"forcefield\")\n    parser.add_argument('-j','--jobfile', dest=\"job_file\", default=\"desmond_setup_1.sh\", help=\"job filename\")\n    parser.add_argument('-m','--msjfile', dest=\"msj_file\", default=\"desmond_setup_1.msj\", help=\"msj filename\")\n    parser.add_argument('-a','--appendix', dest=\"appendix\", default=\"\", help=\"job name appendix\")\n    parser.add_argument('mae', nargs=\"+\", help=\"desmond mae file\")\n    args = parser.parse_args()\n\n    if args.appendix:\n        msj_file = args.msj_file[:-4] + \"_\" + args.appendix + \".msj\"\n    else:\n        msj_file = args.msj_file\n\n    if args.appendix:\n        job_file = args.job_file[:-3] + \"_\" + args.appendix + \".sh\"\n    else:\n        job_file = args.job_file\n\n    # job file (.sh) and msj file (.msj) should match\n    while os.path.exists(job_file):\n        splited = job_file.replace(\".sh\",\"\").split(\"_\")\n        splited[-1] = str(int(splited[-1]) + 1)\n        job_file = \"_\".join(splited) + \".sh\"\n\n    while os.path.exists(msj_file):\n        splited = msj_file.replace(\".msj\",\"\").split(\"_\")\n        splited[-1] = str(int(splited[-1]) + 1)\n        msj_file = \"_\".join(splited) + \".msj\"\n\n    with open(msj_file, \"w\") as msj:\n        setup_msj.dot.build_geometry.solvent = str(args.solvent)\n        setup_msj.dot.build_geometry.add_counterion.ion = str(args.counterion)\n        setup_msj.dot.build_geometry.salt.concentration = str(args.conc)\n        setup_msj.dot.build_geometry.box.size = f\"[ {args.dist} {args.dist} {args.dist} ]\"\n        setup_msj.dot.build_geometry.salt.negative_ion = str(args.neg)\n        setup_msj.dot.build_geometry.salt.positive_ion = str(args.pos)\n        if args.cpp:\n            setup_msj.dot.build_geometry.rezero_system = \"False\"\n            args.lipid = \"POPC\"\n        if args.lipid:\n            setup_msj.dot.build_geometry.membrane_box.lipid = str(args.lipid)\n        else:\n            # remove membrane_box block\n            setup_msj.dot.build_geometry.pop(\"membrane_box\")\n        setup_msj.dot.build_geometry.override_forcefield = str(args.forcefield)\n        setup_msj.dot.assign_forcefield.forcefield = str(args.forcefield)\n        setup_msj.dot.assign_forcefield.water = str(args.solvent)\n        setup_msj.write(msj)\n\n\n    with open(\"README\",\"a\") as readme, open(job_file,\"w\") as job:\n        cmd_echo = \"\"\n        for argv in sys.argv:\n            if cmd_echo:\n                cmd_echo += \" \"\n            if \" \" in argv:\n                cmd_echo += f'\"{argv}\"'\n            else:\n                cmd_echo += f'{argv}'\n        readme.write(f\"{cmd_echo}\\n\\n\")\n        readme.write(f\"Force Field   = {args.forcefield}\\n\")\n        readme.write(f\"Solvent       = {args.solvent}\\n\")\n        readme.write(f\"Counter Ion   = {args.counterion}\\n\")\n        readme.write(f\"Positive Ion  = {args.pos}\\n\")\n        readme.write(f\"Negative Ion  = {args.neg}\\n\")\n        readme.write(f\"Concentration = {args.conc} (M)\\n\")\n        readme.write(f\"Size          = {args.dist} (A)\\n\")\n        readme.write(f\"Lipid         = {args.lipid}\\n\")\n        readme.write(f\"msjfile       = {msj_file}\\n\")\n        readme.write(f\"Jobfile       = {job_file}\\n\")\n        readme.write(f\"Input structure(s):\\n\")\n\n        for i, infile in enumerate(args.mae):\n            prefix = os.path.basename(infile).split(\".\")[0]\n            job_name = f\"desmond_setup-{prefix}\"\n            if args.appendix:\n                job_name += f\"-{args.appendix}\"\n            cms_file = f\"{job_name}-out.cms\"\n            job.write(f\"if [ ! -f {cms_file} ]\\n\")\n            job.write(f\"then\\n\")\n            job.write(f\"{multisim} \\\\\\n\")\n            job.write(f\"  -JOBNAME {job_name} \\\\\\n\")\n            job.write(f\"  -m {msj_file} {os.path.abspath(infile)} \\\\\\n\") \n            job.write(f\"  -o {cms_file} \\\\\\n\")\n            job.write(f\"  -HOST localhost:20 -maxjob 20 -WAIT\\n\")\n            job.write(f\"fi\\n\")\n            readme.write(f\"[{i+1:02d}] {infile}\\n\")\n        readme.write(\"\\n\\n\")\n\n    os.chmod(job_file, 0o777)\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.index_or_asl","title":"<code>index_or_asl(expr)</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def index_or_asl(expr:str) -&gt; str:\n    if len(expr.split()) == 1:\n        return expr\n    else:\n        return f'\"{expr}\"'\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.mdinfo","title":"<code>mdinfo()</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def mdinfo():\n    simulation_time = re.compile(r'last_time = \"(?P&lt;t&gt;[.0-9]+)\"')\n    #    last_time = \"100000.0\"\n    progress = re.compile(r'Chemical time:\\s+(?P&lt;finished&gt;[.0-9]+) ps, Step:\\s+[0-9]+, ns/day:\\s+(?P&lt;rate&gt;[.0-9]+)')\n    #Chemical time:         33507.6000 ps, Step: 5584600, ns/day:      296.231\n\n    parser = argparse.ArgumentParser(description=\"desmond MD info.\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('-t', '--tmpdir', dest='tmpdir', default=None, help='desmond temporary directory')\n    parser.add_argument('-l', '--logfile', dest='logfile', default=None)\n    args = parser.parse_args()\n\n    if args.tmpdir is None:\n        with open(schrodinger_hosts, \"r\") as f:\n            for line in f:\n                if line.strip().startswith(\"#\"):\n                    continue\n                c = line.strip().split(\":\")\n                if len(c) != 2: \n                    continue\n                k = c[0].strip()\n                v = c[1].strip()\n                if k == 'tmpdir':\n                    args.tmpdir = os.path.join(v, USER)\n            if not os.path.exists(args.tmpdir):\n                sys.stderr.write(\"Use -t or --tmpdir to give temporary directory\\n\")\n                sys.exit(1)\n\n\n    if args.logfile is None:\n        args.logfile = args.tmpdir+\"/desmond_*/*.log\"\n        logfile = None\n        for f in glob.glob(args.logfile):\n            if not \"multisim\" in f:\n                logfile = f\n                break\n        if not logfile:\n            sys.stderr.write(f\"desmond log not found in {args.logfile}\\n\")\n            sys.stderr.write(\"Use -l or --logfile to give log file path\\n\")\n            sys.stderr.write(\"Use -t or --tmpdir to give temporary directory\\n\")\n            sys.exit(2)\n\n\n    total = None\n    rate = []\n    with open(logfile,\"r\") as f:\n        for line in f:\n            m = simulation_time.search(line)\n            n = progress.search(line)\n            if not total and m and m.group(\"t\"):\n                total = float(m.group(\"t\"))*0.001\n            if n and n.group(\"finished\") and n.group(\"rate\"):\n                rate.append(float(n.group(\"rate\")))\n                finished = float(n.group(\"finished\"))*0.001\n\n        n = len(rate)\n        print(\"-\"*80)\n        print(f\"| SCHRODINGER= {SCHRODINGER}\")\n        print(f\"| tmpdir: {args.tmpdir}\")\n        print(f\"|\")\n        print(f\"| Desmond MD Timing Info\")\n        print(f\"| ----------------------\")\n        print(f\"|\")\n        print(f\"| {os.path.dirname(logfile)}/\")\n        print(f\"| {os.path.basename(logfile)}\")\n        print(f\"|\")\n\n        if n == 0:\n            if total:\n                print(f\"| Total     {total:9.2f} ns\")\n            print(f\"| Timing data not available yet\")\n            print(\"-\"*80)\n            sys.exit(0)\n\n        remaining = total-finished\n        avg_rate = sum(rate[-n:])/n\n        eta = 24.0*remaining/avg_rate # hours\n        eta_time = datetime.now() + timedelta(hours=eta)\n        print(f\"| Total     {total:9.2f} ns\")\n        print(f\"| Completed {finished:9.2f} ns ({100.0*finished/total:5.1f}%)\")\n        print(f\"| Remaining {remaining:9.2f} ns\")\n        print(f\"| \")\n        print(f\"| Average timings\")\n        print(f\"|    ns/day = {avg_rate:9.2f}\")\n        print(f\"| \")\n        print(f\"| Estimated time\")\n        print(f\"|    remaining = {eta:.2f} hours\")\n        print(f\"|    completed = {eta_time.ctime()}\")\n        print(\"-\"*80)\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.cli.read_eaf","title":"<code>read_eaf(filename, verbose=False)</code>","text":"Source code in <code>mdscribe/desmond/cli.py</code> <pre><code>def read_eaf(filename, verbose=False):\n    HBond = {}\n    Hydrophobic = {}\n    WaterBridge = {}\n    Polar = {}\n    HalogenBond = {}\n    LigWat = {}\n    Metal = {}\n    PiCat = {}\n    PiPi = {}\n\n    result = desmond.expr.parse_file(filename)\n    d = result.as_dict()\n    desmond.traverse_dict(d)\n    dot = desmond.DotMap(d)\n\n    for section in dot.Keywords:\n        try:\n            assert section.ProtLigInter.HBondResult\n            num_frames = len(section.ProtLigInter.HBondResult)\n            for frame in section.ProtLigInter.HBondResult:\n                # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n                for (frameno, prot, hbond_type, lig) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in HBond:\n                        HBond[resSeq]['count'] += 1\n                    else:\n                        HBond[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(HBond):\n                fraction = float(HBond[resSeq]['count'])/num_frames\n                if verbose:\n                    print(f\"HBond {HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.HydrophobicResult\n            num_frames = len(section.ProtLigInter.HydrophobicResult)\n            for frame in section.ProtLigInter.HydrophobicResult:\n                # [[0 \"_:PHE_223\" L-FRAG_0 ] [0 \"_:ALA_241\" L-FRAG_0 ]]\n                for (frameno, prot, lig) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in Hydrophobic:\n                        Hydrophobic[resSeq]['count'] += 1\n                    else:\n                        Hydrophobic[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(Hydrophobic):\n                fraction = float(Hydrophobic[resSeq]['count'])/num_frames\n                if verbose:\n                    print(f\"Hydrophobic {Hydrophobic[resSeq]['resName']}_{resSeq} {fraction:5.3f} {num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.PolarResult\n            num_frames = len(section.ProtLigInter.PolarResult)\n            for frame in section.ProtLigInter.PolarResult:\n                # [[1 \"_:GLU_216:OE2\" b \"L-FRAG_1:N3\" 4.45 ]]\n                for (frameno, prot, _, lig, _) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in Polar:\n                        Polar[resSeq]['count'] += 1\n                    else:\n                        Polar[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(Polar):\n                fraction = float(Polar[resSeq]['count'])/num_frames\n                if verbose:\n                    print(f\"Polar {Polar[resSeq]['resName']}_{resSeq} {fraction:5.3f} {num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.WaterBridgeResult\n            num_frames = len(section.ProtLigInter.WaterBridgeResult)\n            for frame in section.ProtLigInter.WaterBridgeResult:\n                # [[3 \"_:GLU_216:OE2\" a \"L-FRAG_0:N2\" a 2431 ]]\n                for (frameno, prot, _, lig, _, _) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in WaterBridge:\n                        WaterBridge[resSeq]['count'] += 1\n                    else:\n                        WaterBridge[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(WaterBridge):\n                fraction = float(WaterBridge[resSeq]['count'])/num_frames\n                if verbose:\n                    print(f\"WaterBridge {WaterBridge[resSeq]['resName']}_{resSeq} {fraction:5.3f} {num_frames}\")\n        except:\n            pass\n\n    return num_frames, HBond, Hydrophobic, Polar, WaterBridge, HalogenBond, LigWat, Metal, PiCat, PiPi\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond","title":"<code>mdscribe.desmond</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim","title":"<code>Multisim</code>","text":"<p>Parsing Desmond multisim .cfg and .msj expressions</p> Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>class Multisim:\n    \"\"\"Parsing Desmond multisim .cfg and .msj expressions\"\"\"\n    # variable, value, array, expr\n    # pyparsing module\u2019s default behavior is to ignore whitespace.\n    # +: AND, |: MatchFirst, left-to-right, ^: Or(longest match)\n    # Group: --&gt; list\n    # Dict: --&gt; dict\n    # Forward: --&gt; recursive\n\n    EQ = pp.Suppress('=')\n    LBRACKET, RBRACKET, LBRACE, RBRACE = map(pp.Literal, \"[]{}\")\n    variable = (pp.Word(pp.alphanums + \"._/?-@\") + \n                pp.Opt(\".\" + pp.Word(pp.alphanums))).set_parse_action(''.join)\n    _string1 = pp.Word(pp.alphanums + \"._/?-@*\")\n    _string2 = pp.quoted_string()\n    _number  = ppc.number()\n    value   = (_string1 | _string2 | _number)\n    array   = pp.Forward()\n    array   &lt;&lt;= pp.Group(LBRACKET + (pp.ZeroOrMore(value | array)) + RBRACKET)\n    expr    = pp.Forward()\n    _expr_0  = (variable + EQ + value)\n    _expr_1  = (variable + EQ + array)\n    _expr_2  = (variable + EQ + pp.Group(\n        LBRACE + pp.ZeroOrMore(expr) + RBRACE ))\n    _expr_3  = (variable + EQ + pp.Group(\n        LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET))\n    _expr_4  = pp.Group(variable + pp.Group(\n        LBRACE + pp.ZeroOrMore( expr ) + RBRACE))\n    expr    &lt;&lt;= pp.OneOrMore(pp.Dict(pp.Group(\n        _expr_0 | _expr_1 | _expr_2 | _expr_3 | _expr_4)))\n    expr.ignore(\"#\" + pp.restOfLine)\n\n\n    def __init__(self, **kwargs):\n        self.template_path = None\n        self.ParseResults = None\n        self.dict = {}\n        self.dot = DotMap()\n        self.output = sys.stdout # do not attempt to close\n        self.indent = 4\n\n        if 'template' in kwargs:\n            template = kwargs['template']\n            template_path = pathlib.Path(template)\n            if template_path.is_file():\n                self.template_path = template_path\n            else:\n                with importlib.resources.files('mdscribe.desmond') as template_path:\n                    self.template_path = template_path / template\n            if self.template_path is None:\n                raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n            self.ParseResults = Multisim.expr.parse_file(self.template_path)\n            self.decode()\n\n        elif 'string' in kwargs:\n            string = kwargs['string']\n            try:\n                self.ParseResults = Multisim.expr.parse_string(string)\n                self.decode()\n            except:\n                raise RuntimeError(\"Multisim: cannot parse the input string.\")\n        else:\n            raise RuntimeError(\"Multisim: template filename or string is required.\")\n\n\n\n    @staticmethod\n    def unfold_dict_key(d) -&gt; None:\n        \"\"\"Unfold '.' in the keys of a dictionary\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        ks = [ k for k in d ]\n        for k in ks:\n            v = d[k]\n            if '.' in k:\n                # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n                _u = None\n                _k = k.split('.')[0]\n                for kk in k.split('.')[-1:0:-1]:\n                    if _u is None:\n                        _u = {kk : v }\n                    else:\n                        _u = {kk : _u}\n                d[_k] = _u\n                del d[k]\n            else:\n                pass\n            if isinstance(v, dict):\n                Multisim.unfold_dict_key(v)\n\n\n    @staticmethod\n    def traverse_dict(d) -&gt; None:\n        \"\"\"Recursively traverse a nested dictionary/list\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        if isinstance(d, dict):\n            for k,v in d.items():\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)            \n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n        elif isinstance(d, list):\n            for k,v in enumerate(d):\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)\n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n\n\n    def decode(self) -&gt; None:\n        \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n        # create .dict\n        if isinstance(self.ParseResults.as_list()[0][0], str): # key\n            self.dict = self.ParseResults.as_dict()\n            Multisim.traverse_dict(self.dict)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(self.dict)\n\n        elif isinstance(self.ParseResults.as_list()[0][0], list):\n            self.dict = [] # now self.dict is a list of dictionary\n            for section in self.ParseResults:\n                dict_ = dict(section.as_list())\n                Multisim.traverse_dict(dict_)\n                # handle the case where key has '.'\n                Multisim.unfold_dict_key(dict_)\n                self.dict.append(dict_)\n\n        # create .dot\n        if isinstance(self.dict, list):\n            self.dot = {}\n            for d in self.dict:\n                for k,v in d.items():\n                    if k in self.dot:\n                        if isinstance(self.dot[k], list):\n                            self.dot[k].append(v)\n                        else:\n                            self.dot[k] = [self.dot[k], v]\n                    else:\n                        self.dot[k] = v\n            self.dot = DotMap(self.dot)\n        else:\n            self.dot = DotMap(self.dict)\n\n\n\n    def write(self, output=None):\n        \"\"\"Writes DOT object\"\"\"\n        if isinstance(output, io.IOBase):\n            self.output = output\n        elif isinstance(output, str):\n            self.output = open(output, \"w\")\n\n        if isinstance(self.dict, list):\n            blocks = []\n            for k, v in self.dot.items():\n                if isinstance(v, list):\n                    for vv in v:\n                        blocks.append({k:vv})\n                else:\n                    blocks.append({k:v})\n            for block in blocks:\n                self._write_dict(block, block=True)\n                self.output.write(\"\\n\")\n        else:\n            self._write_dict(self.dot)\n\n\n    def _write_dict(self, d, block=False, depth=0):\n        \"\"\"subroutine of .write() method\"\"\"\n        spc = ' ' * self.indent * depth\n        if isinstance(d, dict) or isinstance(d, DotMap):\n            for k, v in d.items():\n                k = str(k)\n                if v:\n                    if isinstance(v, dict) or isinstance(v, DotMap):\n                        if depth == 0 and block:\n                            self.output.write(spc + k + \" {\\n\")\n                        else:\n                            self.output.write(spc + k + \" = {\\n\")\n                        self._write_dict(v, depth=depth+1)\n                        self.output.write(spc + \"}\\n\")\n                    elif isinstance(v, list):\n                        self.output.write(spc + k + \" = [\")\n                        for vv in v:\n                            if isinstance(vv, dict) or isinstance(vv, DotMap): \n                                self.output.write(\"{\\n\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"[\")\n                            self._write_dict(vv, depth=depth+1)\n                            if isinstance(vv, dict) or isinstance(vv, DotMap):\n                                self.output.write(spc + \"}\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"]\")                \n                        self.output.write(\"]\\n\")\n                    else:\n                        self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n                else:\n                    if isinstance(v, list) and (not bool(v)):\n                        self.output.write(spc + k + \" = []\\n\")\n                    elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                        self.output.write(spc + k + \" = {\\n}\\n\")\n                    else:\n                        self.output.write(spc + k + \" =   \\n\")\n        elif isinstance(d, list):\n            for v in d:\n                self._write_dict(v, depth=depth+1)\n        else:\n            self.output.write(\" \" + str(d) + \" \")\n\n\n    def to_dot(self) -&gt; DotMap:\n        \"\"\"Returns parsed results as a DotMap object\n\n        Returns:\n            DotMap : DotMap object\n        \"\"\"\n        return self.dot\n\n\n    def to_list(self) -&gt; list:\n        \"\"\"Returns parsed results as a list\n\n        Returns:\n            list : list\n        \"\"\"\n        return self.ParseResults.as_list()\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Returns parsed results as a dictionary\n\n        Returns:\n            dict : dictionary\n        \"\"\"\n        return self.dict\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.Multisim.EQ","title":"<code>EQ = pp.Suppress('=')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.ParseResults","title":"<code>ParseResults = Multisim.expr.parse_string(string)</code>  <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim._expr_0","title":"<code>_expr_0 = variable + EQ + value</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim._expr_1","title":"<code>_expr_1 = variable + EQ + array</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim._expr_2","title":"<code>_expr_2 = variable + EQ + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim._expr_3","title":"<code>_expr_3 = variable + EQ + pp.Group(LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim._expr_4","title":"<code>_expr_4 = pp.Group(variable + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim._number","title":"<code>_number = ppc.number()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim._string1","title":"<code>_string1 = pp.Word(pp.alphanums + '._/?-@*')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim._string2","title":"<code>_string2 = pp.quoted_string()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.array","title":"<code>array = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.dict","title":"<code>dict = {}</code>  <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.dot","title":"<code>dot = DotMap()</code>  <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.expr","title":"<code>expr = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.indent","title":"<code>indent = 4</code>  <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.output","title":"<code>output = sys.stdout</code>  <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.template_path","title":"<code>template_path = template_path / template</code>  <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.value","title":"<code>value = _string1 | _string2 | _number</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.variable","title":"<code>variable = pp.Word(pp.alphanums + '._/?-@') + pp.Opt('.' + pp.Word(pp.alphanums)).set_parse_action(''.join)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"desmond.html#mdscribe.desmond.Multisim.__init__","title":"<code>__init__(**kwargs)</code>","text":"Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>def __init__(self, **kwargs):\n    self.template_path = None\n    self.ParseResults = None\n    self.dict = {}\n    self.dot = DotMap()\n    self.output = sys.stdout # do not attempt to close\n    self.indent = 4\n\n    if 'template' in kwargs:\n        template = kwargs['template']\n        template_path = pathlib.Path(template)\n        if template_path.is_file():\n            self.template_path = template_path\n        else:\n            with importlib.resources.files('mdscribe.desmond') as template_path:\n                self.template_path = template_path / template\n        if self.template_path is None:\n            raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n        self.ParseResults = Multisim.expr.parse_file(self.template_path)\n        self.decode()\n\n    elif 'string' in kwargs:\n        string = kwargs['string']\n        try:\n            self.ParseResults = Multisim.expr.parse_string(string)\n            self.decode()\n        except:\n            raise RuntimeError(\"Multisim: cannot parse the input string.\")\n    else:\n        raise RuntimeError(\"Multisim: template filename or string is required.\")\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.Multisim._write_dict","title":"<code>_write_dict(d, block=False, depth=0)</code>","text":"<p>subroutine of .write() method</p> Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>def _write_dict(self, d, block=False, depth=0):\n    \"\"\"subroutine of .write() method\"\"\"\n    spc = ' ' * self.indent * depth\n    if isinstance(d, dict) or isinstance(d, DotMap):\n        for k, v in d.items():\n            k = str(k)\n            if v:\n                if isinstance(v, dict) or isinstance(v, DotMap):\n                    if depth == 0 and block:\n                        self.output.write(spc + k + \" {\\n\")\n                    else:\n                        self.output.write(spc + k + \" = {\\n\")\n                    self._write_dict(v, depth=depth+1)\n                    self.output.write(spc + \"}\\n\")\n                elif isinstance(v, list):\n                    self.output.write(spc + k + \" = [\")\n                    for vv in v:\n                        if isinstance(vv, dict) or isinstance(vv, DotMap): \n                            self.output.write(\"{\\n\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"[\")\n                        self._write_dict(vv, depth=depth+1)\n                        if isinstance(vv, dict) or isinstance(vv, DotMap):\n                            self.output.write(spc + \"}\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"]\")                \n                    self.output.write(\"]\\n\")\n                else:\n                    self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n            else:\n                if isinstance(v, list) and (not bool(v)):\n                    self.output.write(spc + k + \" = []\\n\")\n                elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                    self.output.write(spc + k + \" = {\\n}\\n\")\n                else:\n                    self.output.write(spc + k + \" =   \\n\")\n    elif isinstance(d, list):\n        for v in d:\n            self._write_dict(v, depth=depth+1)\n    else:\n        self.output.write(\" \" + str(d) + \" \")\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.Multisim.decode","title":"<code>decode()</code>","text":"<p>decode the parsed results into a dictionary and its dotmap</p> Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>def decode(self) -&gt; None:\n    \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n    # create .dict\n    if isinstance(self.ParseResults.as_list()[0][0], str): # key\n        self.dict = self.ParseResults.as_dict()\n        Multisim.traverse_dict(self.dict)\n        # handle the case where key has '.'\n        Multisim.unfold_dict_key(self.dict)\n\n    elif isinstance(self.ParseResults.as_list()[0][0], list):\n        self.dict = [] # now self.dict is a list of dictionary\n        for section in self.ParseResults:\n            dict_ = dict(section.as_list())\n            Multisim.traverse_dict(dict_)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(dict_)\n            self.dict.append(dict_)\n\n    # create .dot\n    if isinstance(self.dict, list):\n        self.dot = {}\n        for d in self.dict:\n            for k,v in d.items():\n                if k in self.dot:\n                    if isinstance(self.dot[k], list):\n                        self.dot[k].append(v)\n                    else:\n                        self.dot[k] = [self.dot[k], v]\n                else:\n                    self.dot[k] = v\n        self.dot = DotMap(self.dot)\n    else:\n        self.dot = DotMap(self.dict)\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.Multisim.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns parsed results as a dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary</p> Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns parsed results as a dictionary\n\n    Returns:\n        dict : dictionary\n    \"\"\"\n    return self.dict\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.Multisim.to_dot","title":"<code>to_dot()</code>","text":"<p>Returns parsed results as a DotMap object</p> <p>Returns:</p> Name Type Description <code>DotMap</code> <code>DotMap</code> <p>DotMap object</p> Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>def to_dot(self) -&gt; DotMap:\n    \"\"\"Returns parsed results as a DotMap object\n\n    Returns:\n        DotMap : DotMap object\n    \"\"\"\n    return self.dot\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.Multisim.to_list","title":"<code>to_list()</code>","text":"<p>Returns parsed results as a list</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list</p> Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>def to_list(self) -&gt; list:\n    \"\"\"Returns parsed results as a list\n\n    Returns:\n        list : list\n    \"\"\"\n    return self.ParseResults.as_list()\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.Multisim.traverse_dict","title":"<code>traverse_dict(d)</code>  <code>staticmethod</code>","text":"<p>Recursively traverse a nested dictionary/list</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>@staticmethod\ndef traverse_dict(d) -&gt; None:\n    \"\"\"Recursively traverse a nested dictionary/list\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    if isinstance(d, dict):\n        for k,v in d.items():\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)            \n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n    elif isinstance(d, list):\n        for k,v in enumerate(d):\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)\n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.Multisim.unfold_dict_key","title":"<code>unfold_dict_key(d)</code>  <code>staticmethod</code>","text":"<p>Unfold '.' in the keys of a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>@staticmethod\ndef unfold_dict_key(d) -&gt; None:\n    \"\"\"Unfold '.' in the keys of a dictionary\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    ks = [ k for k in d ]\n    for k in ks:\n        v = d[k]\n        if '.' in k:\n            # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n            _u = None\n            _k = k.split('.')[0]\n            for kk in k.split('.')[-1:0:-1]:\n                if _u is None:\n                    _u = {kk : v }\n                else:\n                    _u = {kk : _u}\n            d[_k] = _u\n            del d[k]\n        else:\n            pass\n        if isinstance(v, dict):\n            Multisim.unfold_dict_key(v)\n</code></pre>"},{"location":"desmond.html#mdscribe.desmond.Multisim.write","title":"<code>write(output=None)</code>","text":"<p>Writes DOT object</p> Source code in <code>mdscribe/desmond/multisim.py</code> <pre><code>def write(self, output=None):\n    \"\"\"Writes DOT object\"\"\"\n    if isinstance(output, io.IOBase):\n        self.output = output\n    elif isinstance(output, str):\n        self.output = open(output, \"w\")\n\n    if isinstance(self.dict, list):\n        blocks = []\n        for k, v in self.dot.items():\n            if isinstance(v, list):\n                for vv in v:\n                    blocks.append({k:vv})\n            else:\n                blocks.append({k:v})\n        for block in blocks:\n            self._write_dict(block, block=True)\n            self.output.write(\"\\n\")\n    else:\n        self._write_dict(self.dot)\n</code></pre>"},{"location":"helper.html","title":"Helper","text":""},{"location":"helper.html#mdscribe.helper","title":"<code>mdscribe.helper</code>","text":""},{"location":"helper.html#mdscribe.helper.GlcNAC","title":"<code>GlcNAC = {'HN2': 'H2N', 'C7': 'C2N', 'O7': 'O2N', 'C8': 'CME', 'H81': 'H1M', 'H82': 'H3M', 'H83': 'H2M', 'HO3': 'H3O', 'HO4': 'H4O', 'H61': 'H62', 'H62': 'H61', 'HO6': 'H6O'}</code>  <code>module-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.nucleic_1_3","title":"<code>nucleic_1_3 = {'A': 'ADE', 'G': 'GUA', 'C': 'CYT', 'U': 'URA', 'T': 'THY'}</code>  <code>module-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.nucleic_3_1","title":"<code>nucleic_3_1 = {'ADE': 'A', 'GUA': 'G', 'CYT': 'C', 'URA': 'U', 'THY': 'T'}</code>  <code>module-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.protein_1_3","title":"<code>protein_1_3 = {'G': 'GLY', 'A': 'ALA', 'V': 'VAL', 'L': 'LEU', 'I': 'ILE', 'M': 'MET', 'P': 'PRO', 'F': 'PHE', 'W': 'TRP', 'S': 'SER', 'T': 'THR', 'N': 'ASN', 'Q': 'GLN', 'Y': 'TYR', 'C': 'CYS', 'K': 'LYS', 'R': 'ARG', 'H': 'HIS', 'D': 'ASP', 'E': 'GLU'}</code>  <code>module-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.protein_3_1","title":"<code>protein_3_1 = {'ALA': 'A', 'ARG': 'R', 'ASN': 'N', 'ASP': 'D', 'CYS': 'C', 'GLU': 'E', 'GLN': 'Q', 'GLY': 'G', 'HIS': 'H', 'ILE': 'I', 'LEU': 'L', 'LYS': 'K', 'MET': 'M', 'PHE': 'F', 'PRO': 'P', 'SER': 'S', 'THR': 'T', 'TRP': 'W', 'TYR': 'Y', 'VAL': 'V'}</code>  <code>module-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.MOL2file","title":"<code>MOL2file</code>","text":"<p>Class for handling MOL2 file.</p> Source code in <code>mdscribe/helper/mol2file.py</code> <pre><code>class MOL2file:\n    \"\"\"Class for handling MOL2 file.\"\"\"\n\n    # class bound variable\n    name_syntax = re.compile(r'(?P&lt;element&gt;[a-zA-Z]+)(?P&lt;serial&gt;\\d+)')\n\n    def __init__(self, filename:str | pathlib.Path):\n        self.n_atoms = 0\n        self.blocks = {}\n        self.coords = None # To be modified\n        self.pdblines = [] # reserved for PDB conversion\n\n        cursor = None\n        with open(filename, 'r') as f:\n            for i, line in enumerate(f):\n                if \"@&lt;TRIPOS&gt;\" in line:\n                    cursor = line.split(\"@&lt;TRIPOS&gt;\")[1].strip().lower()\n                    self.blocks[cursor] = []\n                    continue\n                elif line.startswith('#') or line == '\\n':\n                    continue\n                self.blocks[cursor].append(line)\n\n        try:\n            self.n_atoms = len(self.blocks['atom'])\n            assert self.n_atoms &gt; 0\n        except:\n            print(\"MOL2 block has no atom\")\n            sys.exit(0)\n\n        try:\n            assert len(self.blocks['bond']) &gt; 0\n        except:\n            print(\"MOL2 block has no bond\")\n            sys.exit(0)\n\n        self.coords = np.zeros((self.n_atoms, 3), dtype=np.float32)\n\n        altLoc = ' '\n        chainId = ' '\n        iCode = ' '\n        occupancy = 1.0\n        tempFactor = 0.0\n        segId = ' '\n        for i, a in enumerate(self.blocks['atom']):\n            aid, name, x, y, z, atom_type, resid, resname, charge = a.split()[:9]\n            x, y, z = float(x), float(y), float(z)\n            self.coords[i, :] = x, y, z\n            m = MOL2file.name_syntax.match(name)\n            element = m.group(\"element\")\n            self.pdblines.append(\n                f\"HETATM {(i+1):&gt;5} {name:&lt;4}{altLoc}{resname:&lt;3} {chainId}{resid:&lt;4}{iCode}   {x:8.3f}{y:8.3f}{z:8.3f}{occupancy:6.2f}{tempFactor:6.2f}      {segId:&lt;4}{element:&lt;2}{charge:&lt;2}\"\n            )\n\n        for i, b in enumerate(self.blocks['bond']):\n            bid, atom_1, atom_2, bond_type = b.split()[:4]\n            _pdb  = f\"CONECT {atom_1:&gt;5} {atom_2:&gt;5}\"\n            self.pdblines.append(_pdb)\n\n\n    def write(self, filename:str | pathlib.Path) -&gt; None:\n        \"\"\"Write to a file.\n\n        Args:\n            filename (str | pathlib.Path): output filename.\n        \"\"\"\n        with open(filename, 'w') as f:\n            i = 0\n            for cursor in ['molecule', 'atom', 'bond', 'substructure']:\n                if not cursor in self.blocks:\n                    continue\n                f.write(f\"@&lt;TRIPOS&gt;{cursor.upper()}\\n\")\n                i += 1\n                if cursor == 'atom':\n                    k = 0\n                for line in self.blocks[cursor]:\n                    if cursor != 'atom':\n                        f.write(line)\n                    else:    \n                        aid, name, x, y, z, atom_type, resid, resname, charge = line.split()[:9]\n                        # override x,y,z with self.coords\n                        f.write(\"{0:&gt;4} {1:&gt;4} {2:&gt;13.4f} {3:&gt;9.4f} {4:&gt;9.4f} {5:&gt;4} {6} {7} {8:&gt;7.4f}\\n\".format(\n                            aid, \n                            name, \n                            self.coords[k, 0], \n                            self.coords[k, 1], \n                            self.coords[k, 2],\n                            atom_type,\n                            resid,\n                            resname,\n                            float(charge),\n                        ))\n                        k += 1\n\n\n    def transform(self, R:np.ndarray, T:np.ndarray) -&gt; None:\n        \"\"\"Apply rotation/translation to the coordinates.\n\n        Args:\n            R (np.ndarray): 3x3 rotation matrix\n            T (np.ndarray): translation vector\n        \"\"\"\n        com = np.mean(self.coords, axis=0)\n        self.coords = np.dot(self.coords - com, R) + T\n</code></pre>"},{"location":"helper.html#mdscribe.helper.MOL2file.blocks","title":"<code>blocks = {}</code>  <code>instance-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.MOL2file.coords","title":"<code>coords = np.zeros((self.n_atoms, 3), dtype=np.float32)</code>  <code>instance-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.MOL2file.n_atoms","title":"<code>n_atoms = len(self.blocks['atom'])</code>  <code>instance-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.MOL2file.name_syntax","title":"<code>name_syntax = re.compile('(?P&lt;element&gt;[a-zA-Z]+)(?P&lt;serial&gt;\\\\d+)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.MOL2file.pdblines","title":"<code>pdblines = []</code>  <code>instance-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.MOL2file.__init__","title":"<code>__init__(filename)</code>","text":"Source code in <code>mdscribe/helper/mol2file.py</code> <pre><code>def __init__(self, filename:str | pathlib.Path):\n    self.n_atoms = 0\n    self.blocks = {}\n    self.coords = None # To be modified\n    self.pdblines = [] # reserved for PDB conversion\n\n    cursor = None\n    with open(filename, 'r') as f:\n        for i, line in enumerate(f):\n            if \"@&lt;TRIPOS&gt;\" in line:\n                cursor = line.split(\"@&lt;TRIPOS&gt;\")[1].strip().lower()\n                self.blocks[cursor] = []\n                continue\n            elif line.startswith('#') or line == '\\n':\n                continue\n            self.blocks[cursor].append(line)\n\n    try:\n        self.n_atoms = len(self.blocks['atom'])\n        assert self.n_atoms &gt; 0\n    except:\n        print(\"MOL2 block has no atom\")\n        sys.exit(0)\n\n    try:\n        assert len(self.blocks['bond']) &gt; 0\n    except:\n        print(\"MOL2 block has no bond\")\n        sys.exit(0)\n\n    self.coords = np.zeros((self.n_atoms, 3), dtype=np.float32)\n\n    altLoc = ' '\n    chainId = ' '\n    iCode = ' '\n    occupancy = 1.0\n    tempFactor = 0.0\n    segId = ' '\n    for i, a in enumerate(self.blocks['atom']):\n        aid, name, x, y, z, atom_type, resid, resname, charge = a.split()[:9]\n        x, y, z = float(x), float(y), float(z)\n        self.coords[i, :] = x, y, z\n        m = MOL2file.name_syntax.match(name)\n        element = m.group(\"element\")\n        self.pdblines.append(\n            f\"HETATM {(i+1):&gt;5} {name:&lt;4}{altLoc}{resname:&lt;3} {chainId}{resid:&lt;4}{iCode}   {x:8.3f}{y:8.3f}{z:8.3f}{occupancy:6.2f}{tempFactor:6.2f}      {segId:&lt;4}{element:&lt;2}{charge:&lt;2}\"\n        )\n\n    for i, b in enumerate(self.blocks['bond']):\n        bid, atom_1, atom_2, bond_type = b.split()[:4]\n        _pdb  = f\"CONECT {atom_1:&gt;5} {atom_2:&gt;5}\"\n        self.pdblines.append(_pdb)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.MOL2file.transform","title":"<code>transform(R, T)</code>","text":"<p>Apply rotation/translation to the coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>R</code> <code>ndarray</code> <p>3x3 rotation matrix</p> required <code>T</code> <code>ndarray</code> <p>translation vector</p> required Source code in <code>mdscribe/helper/mol2file.py</code> <pre><code>def transform(self, R:np.ndarray, T:np.ndarray) -&gt; None:\n    \"\"\"Apply rotation/translation to the coordinates.\n\n    Args:\n        R (np.ndarray): 3x3 rotation matrix\n        T (np.ndarray): translation vector\n    \"\"\"\n    com = np.mean(self.coords, axis=0)\n    self.coords = np.dot(self.coords - com, R) + T\n</code></pre>"},{"location":"helper.html#mdscribe.helper.MOL2file.write","title":"<code>write(filename)</code>","text":"<p>Write to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path</code> <p>output filename.</p> required Source code in <code>mdscribe/helper/mol2file.py</code> <pre><code>def write(self, filename:str | pathlib.Path) -&gt; None:\n    \"\"\"Write to a file.\n\n    Args:\n        filename (str | pathlib.Path): output filename.\n    \"\"\"\n    with open(filename, 'w') as f:\n        i = 0\n        for cursor in ['molecule', 'atom', 'bond', 'substructure']:\n            if not cursor in self.blocks:\n                continue\n            f.write(f\"@&lt;TRIPOS&gt;{cursor.upper()}\\n\")\n            i += 1\n            if cursor == 'atom':\n                k = 0\n            for line in self.blocks[cursor]:\n                if cursor != 'atom':\n                    f.write(line)\n                else:    \n                    aid, name, x, y, z, atom_type, resid, resname, charge = line.split()[:9]\n                    # override x,y,z with self.coords\n                    f.write(\"{0:&gt;4} {1:&gt;4} {2:&gt;13.4f} {3:&gt;9.4f} {4:&gt;9.4f} {5:&gt;4} {6} {7} {8:&gt;7.4f}\\n\".format(\n                        aid, \n                        name, \n                        self.coords[k, 0], \n                        self.coords[k, 1], \n                        self.coords[k, 2],\n                        atom_type,\n                        resid,\n                        resname,\n                        float(charge),\n                    ))\n                    k += 1\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile","title":"<code>PDBfile</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>class PDBfile:\n    def __init__(self, pdbfile:str | Path) -&gt; None:\n        self.parser = PDBParser()\n        self.st = self.parser.get_structure(\"USER_PDB\", pdbfile)\n        # atomic coordinates\n        coords = []\n        for model in self.st:\n            for chain in model:\n                for residue in chain:\n                    for atom in residue:\n                        coords.append(atom.get_coord())\n        self.coords = np.array(coords)\n        self.shape = self.coords.shape\n\n\n    def center_of_geometry(self) -&gt; np.ndarray:\n        return np.mean(self.coords, axis=0)\n\n\n    def update_coord(self, coords:np.ndarray) -&gt; None:\n        assert self.coords.shape == coords.shape, \"Matrix dimensions must match\"\n        # update atomic coordinates\n        atom_idx = 0\n        for model in self.st:\n            for chain in model:\n                for residue in chain:\n                    for atom in residue:\n                        atom.coord = coords[atom_idx,:]\n                        atom_idx += 1\n\n\n    def transform(self,\n                  centroid: np.ndarray = np.array([0., 0., 0.]),\n                  rot:np.ndarray = np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]]),\n                  trans:np.ndarray = np.array([0., 0., 0.])) -&gt; None:\n        try:\n            assert rot.shape == (3,3)\n        except:\n            raise ValueError('shape of rotation matrix should be (3,3)')\n        try:\n            assert trans.shape == (3,)\n        except:\n            raise ValueError('shape of translation matrix should be (3,)')\n\n        # rotation\n        self.coords = np.dot(self.coords - centroid, rot.T) + centroid\n\n        # translation\n        self.coords = self.coords + trans\n\n        # update atomic coordinates\n        atom_idx = 0\n        for model in self.st:\n            for chain in model:\n                for residue in chain:\n                    for atom in residue:\n                        atom.coord = self.coords[atom_idx,:]\n                        atom_idx += 1\n\n\n    def get_seqeunce(self) -&gt; None:\n        wrap= 50\n        for model in self.st:\n            prev_residue_number = None\n            header = \"Model \"+ str(model.id)\n            sequence = \"\"\n            for chain in model:\n                print(\"chain=\", chain)\n                for residue in chain:\n                    resname = residue.get_resname()\n                    if not resname in aminoacids:\n                        continue\n                    hetflag,resseq,iCode = residue.get_id()\n                    resSeq = int(resseq)\n                    if prev_residue_number is None:\n                        print(\"(first residue) %4d\" % resSeq)\n                    else:\n                        num_missing_residues = resSeq-prev_residue_number-1\n                        if num_missing_residues &gt; 0:\n                            sequence += \"-\" * num_missing_residues\n                            print(\"(missing residues) %4d - %4d (%d)\" %\n                                (prev_residue_number+1,resSeq-1,num_missing_residues))\n                    sequence += aminoacids[resname]\n                    prev_residue_number = resSeq\n                print(\"(last residue) %4d\" % resSeq)\n                # output\n                print(header)\n                l= len(sequence)//wrap\n                for i in range(0,l):\n                    start = wrap*i\n                    end = max(wrap*(i+1),l)\n                    print(sequence[start:end])\n\n\n    @staticmethod\n    def readlines(pdbfile:str):\n        \"\"\"(Not Used) Read PDB Lines.\n\n        Args:\n            pdbfile (str): filename.\n        \"\"\"\n        pdblines = {1: []}\n        with open(pdbfile, \"r\") as f:\n            for line in f:\n                if line.startswith(\"MODEL\"):\n                    model_number = int(line.strip().split()[1])\n                    pdblines[model_number] = []\n\n                if line.startswith(\"ATOM\") or line.startswith(\"HETATM\") or line.startswith(\"TER\"):\n                    # PDB format version 2.3\n                    serial = line[6:12]\n                    name = line[12:16].strip()\n                    altLoc = line[16:17]\n                    if altLoc==\"\":\n                        altLoc=\" \"\n                    resName = line[17:21].strip()\n                    chainId = line[21:22]\n                    if chainId==\"\":\n                        chainId=\" \"\n                    resSeq = int(line[22:26])\n                    iCode = line[26:27]\n                    if iCode==\"\":\n                        iCode=\" \"\n                    x = float(line[30:38])\n                    y = float(line[38:46])\n                    z = float(line[46:54])\n                    occupancy = line[54:60]\n                    tempFactor = float(line[60:66])\n                    segId = line[72:76]\n                    element = line[76:78]\n                    charge = line[78:80]\n\n\n    def write(self, filename: str | Path, \n              model:Optional[List[int]] = None,\n              chain:Optional[List[str]] = None, \n              resname:Optional[List[str]] = None,\n              resnumber:Optional[str] = None,\n              ) -&gt; None:\n        \"\"\"Write to PDB with selections.\n\n        Examples:\n            &gt;&gt;&gt; pdb.write(model=[0], chain=['A'])\n            write chain A and residues first-10,22-50,130-200,550,600-last\n            &gt;&gt;&gt; pdb.write(chain=['A'], resnumber=\"-10,22-50,130-200,550,600-\")\n\n        Args:\n            filename (str | Path): output filename or path\n            model (Optional[List[int]], optional): list of model numbers. Defaults to None.\n            chain (Optional[List[str]], optional): list of chain ids. Defaults to None.\n            resname (Optional[List[str]], optional): list of residue names. Defaults to None.\n            resnumber (Optional[str], optional): residue number ranges. Defaults to None.\n        \"\"\"\n\n        io = PDBIO()\n\n        if (model is None) and (chain is None) and (resname is None) and (resnumber is None):\n            # write structure as it as\n            io.set_structure(self.st)\n        else: \n            # write only select model(s), chain(s) or residue(s)\n            # select residues by numbers\n            if resnumber is not None:\n                select_resseqs = [tuple(map(lambda s: int(s) if s else -1, r.split(\"-\"))) for r in resnumber.split(\",\")]\n                # for resnumber=\"-10,22-50,130-200,550,600-\"\n                # [(-1, 10), (22, 50), (130, 200), (550,), (600, -1)]\n            builder = StructureBuilder()\n            builder.init_structure(self.st.id)\n            for _model in self.st:\n                if (model is not None) and (_model.id not in model):\n                    continue # reject model\n                builder.init_model(_model.id, serial_num=None)\n                for _chain in _model:\n                    if (chain is not None) and (_chain.id not in chain):\n                        continue # reject chain\n                    builder.init_chain(_chain.id)\n                    for _residue in _chain:\n                        hetflag, resseq, iCode = _residue.get_id()\n                        if (resname is not None) and (_residue.resname not in resname):\n                            continue # reject residue by name\n                        # select residue numbers\n                        include_flags = []\n                        for lu in select_resseqs:\n                            if len(lu) == 1:\n                                if lu == resseq:\n                                    include_flags.append(True)\n                                else:\n                                    include_flags.append(False)\n                            else:\n                                (l,u) = lu\n                                if (l == -1 or l &lt;= resseq) and (u ==-1 or u &gt;= resseq):\n                                    include_flags.append(True)\n                                else:\n                                    include_flags.append(False)\n                        if not any(include_flags):\n                            continue # reject residue by number\n                        builder.init_residue(_residue.resname, hetflag, resseq, iCode)\n                        for atom in _residue:\n                            builder.init_atom(atom.name, \n                                            atom.coord, \n                                            atom.bfactor, \n                                            atom.occupancy,\n                                            atom.altloc,\n                                            atom.fullname,\n                                            None, # serial_number\n                                            atom.element,\n                                            )\n            io.set_structure(builder.get_structure())\n        with open(filename, \"w\") as f:\n            io.save(f)\n\n\n\n    def reorder(self) -&gt; None:\n        builder = StructureBuilder()\n        builder.init_structure(self.st.id)\n        for model in self.st:\n            builder.init_model(model.id, serial_num=None)\n            for chain in sorted(model, key=lambda x:x.id):\n                builder.init_chain(chain.id)\n                for residue in sorted(chain, key=lambda x: x.get_id()[1]):\n                    hetflag, resseq, iCode = residue.get_id()\n                    builder.init_residue(residue.resname, hetflag, resseq, iCode)\n                    for atom in residue:\n                        builder.init_atom(atom.name, \n                                        atom.coord, \n                                        atom.bfactor, \n                                        atom.occupancy,\n                                        atom.altloc,\n                                        atom.fullname,\n                                        None, # serial_number\n                                        atom.element,\n                                        )\n        self.st = builder.get_structure()\n\n\n\n    def rename(self, \n               chain:Optional[dict] = None, \n               resname:Optional[dict] = None, \n               atom:Optional[dict] = None) -&gt; None:\n        \"\"\"Rename PDB chains/residues/atoms.\n\n        Examples:\n            Rename chain 'C' to 'A' and 'D' to 'B'.\n            &gt;&gt;&gt; rename(chain={'C':'A', 'D':'B'})\n\n            Rename residue 'UNL' to 'LIG' for all chains.\n            &gt;&gt;&gt; rename(resname={'UNL' : 'LIG'})\n\n            Rename residue 'UNL' to 'LIG' only for chain B.\n            &gt;&gt;&gt; rename(chain={\"B\":\"B\"}, resname={'UNL' : 'LIG'})\n\n            Rename atom '2H2' to 'H22' for all residues and chains.\n            &gt;&gt;&gt; rename(atom={\"2H2\": \"H22\"})\n\n            Rename atoms 'H1' and 'H2' to 'H11' and 'H12' for chain C and residue UNL.\n            &gt;&gt;&gt; rename(chain={\"C:C\"}, resname={\"UNL\":\"UNL\"}, atom={\"H1\" : \"H11\", \"H2\": \"H12\"})\n\n        Args:\n            chain (Optional[dict], optional): map of chain ids {old:new}. Defaults to None.\n            resname (Optional[dict], optional): map of residue names {old:new}. Defaults to None.\n            atom (Optional[dict], optional): map of atom names {old:new}. Defaults to None.\n        \"\"\"\n        for model in self.st:\n            for _chain in model:\n                if chain is None:\n                    subject_chains = [c.id for c in model.get_chains()]\n                else:\n                    subject_chains = [k for k in chain]\n\n                if _chain.id not in subject_chains:\n                    continue\n\n                if chain:\n                    old_chain_id = _chain.id\n                    new_chain_id = chain[old_chain_id]\n                    _chain.id = new_chain_id\n                    if old_chain_id != new_chain_id:\n                        print(f\"renamed chain id : \", end=\" \")\n                        print(f\"{old_chain_id}\", end=\" -&gt; \")\n                        print(f\"{new_chain_id}\")\n\n                for _residue in _chain:\n                    if resname is None:\n                        subject_resnames = [r.resname for r in _chain.get_residues()]\n                    else:\n                        subject_resnames = [k for k in resname]\n\n                    if _residue.resname not in subject_resnames:\n                        continue\n\n                    hetflag, resseq, iCode = _residue.get_id()\n\n                    if resname:\n                        old_resname = _residue.resname\n                        new_resname = resname[old_resname]\n                        _residue.resname = new_resname\n                        if old_resname != new_resname:\n                            print(f\"renamed residue {_chain.id}\", end=\" : \")\n                            print(f\"{old_resname}({resseq})\", end=\" -&gt;\")\n                            print(f\"{new_resname}({resseq})\")\n                    else:\n                        old_resname = None\n                        new_resname = None\n\n                    for _atom in _residue:\n                        if atom is None:\n                            subject_atoms = [a.name for a in _residue.get_atoms()]\n                        else:\n                            subject_atoms = [k for k in atom]\n\n                        if _atom.name not in subject_atoms:\n                            continue\n\n                        if atom:\n                            old_atom_name = _atom.name\n                            new_atom_name = atom[old_atom_name]\n                            _atom.name = new_atom_name\n                            if old_atom_name != new_atom_name:\n                                print(f\"renamed atom {_chain.id}.{_residue.resname}({resseq})\", end=\" : \")\n                                print(f\"{old_atom_name}\", end=\" -&gt; \")\n                                print(f\"{new_atom_name}\")\n\n\n    def reorient(self, \n                 residue_selection:str=\"\", \n                 invert_Z:bool=False, \n                 offset:np.ndarray=np.array([0.,0.,0.])) -&gt; None:\n        \"\"\"Reorient coordinates according to the principal axis.\n\n        Examples:\n            Chain A residues 12-50 and chain B residues 100-200 will be used for principal axis calculation.\n            &gt;&gt;&gt; pdb.reorient(\"A:12-50,B:100-200\") \n\n        Args:\n            residue_selection (str, optional): residues for principal axis calculation. Defaults to \"\".\n            invert_Z (bool, optional): whether to invert Z axis. Defaults to False.\n            offset (np.ndarray, optional): translate coordinates. Defaults to np.array([0.,0.,0.]).\n        \"\"\"\n        coords = []\n        if residue_selection:\n            subset_residues = {}\n            # subset of atoms for Eigenvector/Eigenvalue calculations\n            for chain in residue_selection.split(\",\"):\n                (chainId, resSeq_range) = chain.split(\":\")\n                resSeq_range_tuple = tuple(sorted(map(int, resSeq_range.split(\"-\"))))\n                if chainId in subset_residues:\n                    subset_residues[chainId].append(resSeq_range_tuple)\n                else:\n                    subset_residues[chainId] = [resSeq_range_tuple]\n            for model in self.st:\n                for chain in model:\n                    if chain.id not in subset_residues:\n                        continue\n                    for residue in chain:\n                        hetflag, resseq, iCode = residue.get_id()\n                        flag = []\n                        for (lb, ub) in subset_residues[chain.id]:\n                            if resseq &gt;= lb and resseq &lt;= ub:\n                                flag.append(True)\n                            else:\n                                flag.append(False)\n                        if any(flag):\n                            coords.extend([atom.coord for atom in residue])\n        else:\n            for model in self.st:\n                for chain in model:\n                    for residue in chain:\n                        coords.extend([atom.coord for atom in residue])\n\n        coords = np.array(coords, float)\n        centroid = np.mean(coords, axis=0)\n        box_min = np.min(coords, axis=0)\n        box_max = np.max(coords, axis=0)\n        print(\"REMARK geometric center:\", centroid)\n        print(\"REMARK coordinate range:\", box_min, box_max)\n        print(\"REMARK box size:\", box_max-box_min)\n\n        coords = coords - centroid\n\n        # import numpy as np\n        # data = np.array([[1, 2], [3, 4], [5, 6]])  # Example data\n        # cov_matrix = np.cov(data, rowvar=False)\n        # eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)\n        # rotation_matrix = eigenvectors\n        # rotated_data = np.dot(data, rotation_matrix.T)\n\n        inertia = np.dot(coords.transpose(), coords)\n        w,v = np.linalg.eig(inertia)\n\n        # warning eigen values are not necessary ordered!\n        # http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html\n        #--------------------------------------------------------------------------\n        # order eigen values (and eigen vectors)\n        #\n        # axis1 is the principal axis with the biggest eigen value (eval1)\n        # axis2 is the principal axis with the second biggest eigen value (eval2)\n        # axis3 is the principal axis with the smallest eigen value (eval3)\n        #--------------------------------------------------------------------------\n        # axis1 --&gt; Z\n        # axis2 --&gt; Y\n        # axis3 --&gt; X\n        order = np.argsort(w)\n        eval3, eval2, eval1 = w[order]\n        axis3, axis2, axis1 = v[:, order]\n\n        print(\"REMARK x-axis\",axis3,\"eval=\",eval3)\n        print(\"REMARK y-axis\",axis2,\"eval=\",eval2)\n        print(\"REMARK z-axis\",axis1,\"eval=\",eval1)\n\n        R = np.array([axis3, axis2, axis1]) # decreasing order\n        # R_inv = np.linalg.inv(R)\n\n        self.transform(rot=R, trans=-centroid)\n        # xyz = np.array([x,y,z])\n        # xyz = xyz - center\n        # xyz = np.dot(R_inv, xyz)\n        # x, y, z = xyz\n        # if args.inverse_z_axis:\n        #     z = -z\n        # x += args.offset_x\n        # y += args.offset_y\n        # z += args.offset_z\n\n\n    @staticmethod\n    def expand_residues(txt):\n        residues = []\n        step1 = txt.split(\",\")\n        for item in step1:\n            step2 = item.split(\"-\")\n            if len(step2) == 2:\n                residues += range(int(step2[0]), int(step2[1])+1)\n            elif len(step2) == 1:\n                residues += [ int(step2[0]) ]\n        return sorted(residues)\n\n\n    def contacts(self, \n                       residue_selection_1:str, \n                       residue_selection_2:str,\n                       cutoff:float=4.0) -&gt; None:\n        residues_1 = PDBfile.expand_residues(residue_selection_1)\n        residues_2 = PDBfile.expand_residues(residue_selection_2)\n\n        source_atoms = []\n        target_atoms = []\n        for model in self.st:\n            for chain in model:\n                for residue in chain:\n                    hetflag, resSeq, iCode = residue.get_id()\n                    resName = residue.get_resname()\n                    if resSeq in residues_1:\n                        source_atoms += [ atom for atom in residue ]\n                    elif resSeq in residues_2:\n                        target_atoms += [ atom for atom in residue ]\n\n        close_contacts = []\n        for ai in source_atoms:\n            for aj in target_atoms:\n                d = ai-aj\n                if d &lt; cutoff:\n                    close_contacts.append((ai, aj, d))\n        close_contacts = sorted(close_contacts, key=lambda x: (x[0], x[1], x[2]))\n        for (ai, aj, d) in close_contacts:\n            i_hetflag, i_resSeq, i_iCode = ai.get_parent().get_id()\n            j_hetflag, j_resSeq, j_iCode = aj.get_parent().get_id()\n            print(\"%4d %4s %4d %4s %3.1f\" % (i_resSeq, ai.id, j_resSeq, aj.id, d))\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.coords","title":"<code>coords = np.array(coords)</code>  <code>instance-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.PDBfile.parser","title":"<code>parser = PDBParser()</code>  <code>instance-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.PDBfile.shape","title":"<code>shape = self.coords.shape</code>  <code>instance-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.PDBfile.st","title":"<code>st = self.parser.get_structure('USER_PDB', pdbfile)</code>  <code>instance-attribute</code>","text":""},{"location":"helper.html#mdscribe.helper.PDBfile.__init__","title":"<code>__init__(pdbfile)</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def __init__(self, pdbfile:str | Path) -&gt; None:\n    self.parser = PDBParser()\n    self.st = self.parser.get_structure(\"USER_PDB\", pdbfile)\n    # atomic coordinates\n    coords = []\n    for model in self.st:\n        for chain in model:\n            for residue in chain:\n                for atom in residue:\n                    coords.append(atom.get_coord())\n    self.coords = np.array(coords)\n    self.shape = self.coords.shape\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.center_of_geometry","title":"<code>center_of_geometry()</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def center_of_geometry(self) -&gt; np.ndarray:\n    return np.mean(self.coords, axis=0)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.contacts","title":"<code>contacts(residue_selection_1, residue_selection_2, cutoff=4.0)</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def contacts(self, \n                   residue_selection_1:str, \n                   residue_selection_2:str,\n                   cutoff:float=4.0) -&gt; None:\n    residues_1 = PDBfile.expand_residues(residue_selection_1)\n    residues_2 = PDBfile.expand_residues(residue_selection_2)\n\n    source_atoms = []\n    target_atoms = []\n    for model in self.st:\n        for chain in model:\n            for residue in chain:\n                hetflag, resSeq, iCode = residue.get_id()\n                resName = residue.get_resname()\n                if resSeq in residues_1:\n                    source_atoms += [ atom for atom in residue ]\n                elif resSeq in residues_2:\n                    target_atoms += [ atom for atom in residue ]\n\n    close_contacts = []\n    for ai in source_atoms:\n        for aj in target_atoms:\n            d = ai-aj\n            if d &lt; cutoff:\n                close_contacts.append((ai, aj, d))\n    close_contacts = sorted(close_contacts, key=lambda x: (x[0], x[1], x[2]))\n    for (ai, aj, d) in close_contacts:\n        i_hetflag, i_resSeq, i_iCode = ai.get_parent().get_id()\n        j_hetflag, j_resSeq, j_iCode = aj.get_parent().get_id()\n        print(\"%4d %4s %4d %4s %3.1f\" % (i_resSeq, ai.id, j_resSeq, aj.id, d))\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.expand_residues","title":"<code>expand_residues(txt)</code>  <code>staticmethod</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>@staticmethod\ndef expand_residues(txt):\n    residues = []\n    step1 = txt.split(\",\")\n    for item in step1:\n        step2 = item.split(\"-\")\n        if len(step2) == 2:\n            residues += range(int(step2[0]), int(step2[1])+1)\n        elif len(step2) == 1:\n            residues += [ int(step2[0]) ]\n    return sorted(residues)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.get_seqeunce","title":"<code>get_seqeunce()</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def get_seqeunce(self) -&gt; None:\n    wrap= 50\n    for model in self.st:\n        prev_residue_number = None\n        header = \"Model \"+ str(model.id)\n        sequence = \"\"\n        for chain in model:\n            print(\"chain=\", chain)\n            for residue in chain:\n                resname = residue.get_resname()\n                if not resname in aminoacids:\n                    continue\n                hetflag,resseq,iCode = residue.get_id()\n                resSeq = int(resseq)\n                if prev_residue_number is None:\n                    print(\"(first residue) %4d\" % resSeq)\n                else:\n                    num_missing_residues = resSeq-prev_residue_number-1\n                    if num_missing_residues &gt; 0:\n                        sequence += \"-\" * num_missing_residues\n                        print(\"(missing residues) %4d - %4d (%d)\" %\n                            (prev_residue_number+1,resSeq-1,num_missing_residues))\n                sequence += aminoacids[resname]\n                prev_residue_number = resSeq\n            print(\"(last residue) %4d\" % resSeq)\n            # output\n            print(header)\n            l= len(sequence)//wrap\n            for i in range(0,l):\n                start = wrap*i\n                end = max(wrap*(i+1),l)\n                print(sequence[start:end])\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.readlines","title":"<code>readlines(pdbfile)</code>  <code>staticmethod</code>","text":"<p>(Not Used) Read PDB Lines.</p> <p>Parameters:</p> Name Type Description Default <code>pdbfile</code> <code>str</code> <p>filename.</p> required Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>@staticmethod\ndef readlines(pdbfile:str):\n    \"\"\"(Not Used) Read PDB Lines.\n\n    Args:\n        pdbfile (str): filename.\n    \"\"\"\n    pdblines = {1: []}\n    with open(pdbfile, \"r\") as f:\n        for line in f:\n            if line.startswith(\"MODEL\"):\n                model_number = int(line.strip().split()[1])\n                pdblines[model_number] = []\n\n            if line.startswith(\"ATOM\") or line.startswith(\"HETATM\") or line.startswith(\"TER\"):\n                # PDB format version 2.3\n                serial = line[6:12]\n                name = line[12:16].strip()\n                altLoc = line[16:17]\n                if altLoc==\"\":\n                    altLoc=\" \"\n                resName = line[17:21].strip()\n                chainId = line[21:22]\n                if chainId==\"\":\n                    chainId=\" \"\n                resSeq = int(line[22:26])\n                iCode = line[26:27]\n                if iCode==\"\":\n                    iCode=\" \"\n                x = float(line[30:38])\n                y = float(line[38:46])\n                z = float(line[46:54])\n                occupancy = line[54:60]\n                tempFactor = float(line[60:66])\n                segId = line[72:76]\n                element = line[76:78]\n                charge = line[78:80]\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.rename","title":"<code>rename(chain=None, resname=None, atom=None)</code>","text":"<p>Rename PDB chains/residues/atoms.</p> <p>Examples:</p> <p>Rename chain 'C' to 'A' and 'D' to 'B'.</p> <pre><code>&gt;&gt;&gt; rename(chain={'C':'A', 'D':'B'})\n</code></pre> <p>Rename residue 'UNL' to 'LIG' for all chains.</p> <pre><code>&gt;&gt;&gt; rename(resname={'UNL' : 'LIG'})\n</code></pre> <p>Rename residue 'UNL' to 'LIG' only for chain B.</p> <pre><code>&gt;&gt;&gt; rename(chain={\"B\":\"B\"}, resname={'UNL' : 'LIG'})\n</code></pre> <p>Rename atom '2H2' to 'H22' for all residues and chains.</p> <pre><code>&gt;&gt;&gt; rename(atom={\"2H2\": \"H22\"})\n</code></pre> <p>Rename atoms 'H1' and 'H2' to 'H11' and 'H12' for chain C and residue UNL.</p> <pre><code>&gt;&gt;&gt; rename(chain={\"C:C\"}, resname={\"UNL\":\"UNL\"}, atom={\"H1\" : \"H11\", \"H2\": \"H12\"})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>Optional[dict]</code> <p>map of chain ids {old:new}. Defaults to None.</p> <code>None</code> <code>resname</code> <code>Optional[dict]</code> <p>map of residue names {old:new}. Defaults to None.</p> <code>None</code> <code>atom</code> <code>Optional[dict]</code> <p>map of atom names {old:new}. Defaults to None.</p> <code>None</code> Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def rename(self, \n           chain:Optional[dict] = None, \n           resname:Optional[dict] = None, \n           atom:Optional[dict] = None) -&gt; None:\n    \"\"\"Rename PDB chains/residues/atoms.\n\n    Examples:\n        Rename chain 'C' to 'A' and 'D' to 'B'.\n        &gt;&gt;&gt; rename(chain={'C':'A', 'D':'B'})\n\n        Rename residue 'UNL' to 'LIG' for all chains.\n        &gt;&gt;&gt; rename(resname={'UNL' : 'LIG'})\n\n        Rename residue 'UNL' to 'LIG' only for chain B.\n        &gt;&gt;&gt; rename(chain={\"B\":\"B\"}, resname={'UNL' : 'LIG'})\n\n        Rename atom '2H2' to 'H22' for all residues and chains.\n        &gt;&gt;&gt; rename(atom={\"2H2\": \"H22\"})\n\n        Rename atoms 'H1' and 'H2' to 'H11' and 'H12' for chain C and residue UNL.\n        &gt;&gt;&gt; rename(chain={\"C:C\"}, resname={\"UNL\":\"UNL\"}, atom={\"H1\" : \"H11\", \"H2\": \"H12\"})\n\n    Args:\n        chain (Optional[dict], optional): map of chain ids {old:new}. Defaults to None.\n        resname (Optional[dict], optional): map of residue names {old:new}. Defaults to None.\n        atom (Optional[dict], optional): map of atom names {old:new}. Defaults to None.\n    \"\"\"\n    for model in self.st:\n        for _chain in model:\n            if chain is None:\n                subject_chains = [c.id for c in model.get_chains()]\n            else:\n                subject_chains = [k for k in chain]\n\n            if _chain.id not in subject_chains:\n                continue\n\n            if chain:\n                old_chain_id = _chain.id\n                new_chain_id = chain[old_chain_id]\n                _chain.id = new_chain_id\n                if old_chain_id != new_chain_id:\n                    print(f\"renamed chain id : \", end=\" \")\n                    print(f\"{old_chain_id}\", end=\" -&gt; \")\n                    print(f\"{new_chain_id}\")\n\n            for _residue in _chain:\n                if resname is None:\n                    subject_resnames = [r.resname for r in _chain.get_residues()]\n                else:\n                    subject_resnames = [k for k in resname]\n\n                if _residue.resname not in subject_resnames:\n                    continue\n\n                hetflag, resseq, iCode = _residue.get_id()\n\n                if resname:\n                    old_resname = _residue.resname\n                    new_resname = resname[old_resname]\n                    _residue.resname = new_resname\n                    if old_resname != new_resname:\n                        print(f\"renamed residue {_chain.id}\", end=\" : \")\n                        print(f\"{old_resname}({resseq})\", end=\" -&gt;\")\n                        print(f\"{new_resname}({resseq})\")\n                else:\n                    old_resname = None\n                    new_resname = None\n\n                for _atom in _residue:\n                    if atom is None:\n                        subject_atoms = [a.name for a in _residue.get_atoms()]\n                    else:\n                        subject_atoms = [k for k in atom]\n\n                    if _atom.name not in subject_atoms:\n                        continue\n\n                    if atom:\n                        old_atom_name = _atom.name\n                        new_atom_name = atom[old_atom_name]\n                        _atom.name = new_atom_name\n                        if old_atom_name != new_atom_name:\n                            print(f\"renamed atom {_chain.id}.{_residue.resname}({resseq})\", end=\" : \")\n                            print(f\"{old_atom_name}\", end=\" -&gt; \")\n                            print(f\"{new_atom_name}\")\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.reorder","title":"<code>reorder()</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def reorder(self) -&gt; None:\n    builder = StructureBuilder()\n    builder.init_structure(self.st.id)\n    for model in self.st:\n        builder.init_model(model.id, serial_num=None)\n        for chain in sorted(model, key=lambda x:x.id):\n            builder.init_chain(chain.id)\n            for residue in sorted(chain, key=lambda x: x.get_id()[1]):\n                hetflag, resseq, iCode = residue.get_id()\n                builder.init_residue(residue.resname, hetflag, resseq, iCode)\n                for atom in residue:\n                    builder.init_atom(atom.name, \n                                    atom.coord, \n                                    atom.bfactor, \n                                    atom.occupancy,\n                                    atom.altloc,\n                                    atom.fullname,\n                                    None, # serial_number\n                                    atom.element,\n                                    )\n    self.st = builder.get_structure()\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.reorient","title":"<code>reorient(residue_selection='', invert_Z=False, offset=np.array([0.0, 0.0, 0.0]))</code>","text":"<p>Reorient coordinates according to the principal axis.</p> <p>Examples:</p> <p>Chain A residues 12-50 and chain B residues 100-200 will be used for principal axis calculation.</p> <pre><code>&gt;&gt;&gt; pdb.reorient(\"A:12-50,B:100-200\") \n</code></pre> <p>Parameters:</p> Name Type Description Default <code>residue_selection</code> <code>str</code> <p>residues for principal axis calculation. Defaults to \"\".</p> <code>''</code> <code>invert_Z</code> <code>bool</code> <p>whether to invert Z axis. Defaults to False.</p> <code>False</code> <code>offset</code> <code>ndarray</code> <p>translate coordinates. Defaults to np.array([0.,0.,0.]).</p> <code>array([0.0, 0.0, 0.0])</code> Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def reorient(self, \n             residue_selection:str=\"\", \n             invert_Z:bool=False, \n             offset:np.ndarray=np.array([0.,0.,0.])) -&gt; None:\n    \"\"\"Reorient coordinates according to the principal axis.\n\n    Examples:\n        Chain A residues 12-50 and chain B residues 100-200 will be used for principal axis calculation.\n        &gt;&gt;&gt; pdb.reorient(\"A:12-50,B:100-200\") \n\n    Args:\n        residue_selection (str, optional): residues for principal axis calculation. Defaults to \"\".\n        invert_Z (bool, optional): whether to invert Z axis. Defaults to False.\n        offset (np.ndarray, optional): translate coordinates. Defaults to np.array([0.,0.,0.]).\n    \"\"\"\n    coords = []\n    if residue_selection:\n        subset_residues = {}\n        # subset of atoms for Eigenvector/Eigenvalue calculations\n        for chain in residue_selection.split(\",\"):\n            (chainId, resSeq_range) = chain.split(\":\")\n            resSeq_range_tuple = tuple(sorted(map(int, resSeq_range.split(\"-\"))))\n            if chainId in subset_residues:\n                subset_residues[chainId].append(resSeq_range_tuple)\n            else:\n                subset_residues[chainId] = [resSeq_range_tuple]\n        for model in self.st:\n            for chain in model:\n                if chain.id not in subset_residues:\n                    continue\n                for residue in chain:\n                    hetflag, resseq, iCode = residue.get_id()\n                    flag = []\n                    for (lb, ub) in subset_residues[chain.id]:\n                        if resseq &gt;= lb and resseq &lt;= ub:\n                            flag.append(True)\n                        else:\n                            flag.append(False)\n                    if any(flag):\n                        coords.extend([atom.coord for atom in residue])\n    else:\n        for model in self.st:\n            for chain in model:\n                for residue in chain:\n                    coords.extend([atom.coord for atom in residue])\n\n    coords = np.array(coords, float)\n    centroid = np.mean(coords, axis=0)\n    box_min = np.min(coords, axis=0)\n    box_max = np.max(coords, axis=0)\n    print(\"REMARK geometric center:\", centroid)\n    print(\"REMARK coordinate range:\", box_min, box_max)\n    print(\"REMARK box size:\", box_max-box_min)\n\n    coords = coords - centroid\n\n    # import numpy as np\n    # data = np.array([[1, 2], [3, 4], [5, 6]])  # Example data\n    # cov_matrix = np.cov(data, rowvar=False)\n    # eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)\n    # rotation_matrix = eigenvectors\n    # rotated_data = np.dot(data, rotation_matrix.T)\n\n    inertia = np.dot(coords.transpose(), coords)\n    w,v = np.linalg.eig(inertia)\n\n    # warning eigen values are not necessary ordered!\n    # http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html\n    #--------------------------------------------------------------------------\n    # order eigen values (and eigen vectors)\n    #\n    # axis1 is the principal axis with the biggest eigen value (eval1)\n    # axis2 is the principal axis with the second biggest eigen value (eval2)\n    # axis3 is the principal axis with the smallest eigen value (eval3)\n    #--------------------------------------------------------------------------\n    # axis1 --&gt; Z\n    # axis2 --&gt; Y\n    # axis3 --&gt; X\n    order = np.argsort(w)\n    eval3, eval2, eval1 = w[order]\n    axis3, axis2, axis1 = v[:, order]\n\n    print(\"REMARK x-axis\",axis3,\"eval=\",eval3)\n    print(\"REMARK y-axis\",axis2,\"eval=\",eval2)\n    print(\"REMARK z-axis\",axis1,\"eval=\",eval1)\n\n    R = np.array([axis3, axis2, axis1]) # decreasing order\n    # R_inv = np.linalg.inv(R)\n\n    self.transform(rot=R, trans=-centroid)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.transform","title":"<code>transform(centroid=np.array([0.0, 0.0, 0.0]), rot=np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]), trans=np.array([0.0, 0.0, 0.0]))</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def transform(self,\n              centroid: np.ndarray = np.array([0., 0., 0.]),\n              rot:np.ndarray = np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]]),\n              trans:np.ndarray = np.array([0., 0., 0.])) -&gt; None:\n    try:\n        assert rot.shape == (3,3)\n    except:\n        raise ValueError('shape of rotation matrix should be (3,3)')\n    try:\n        assert trans.shape == (3,)\n    except:\n        raise ValueError('shape of translation matrix should be (3,)')\n\n    # rotation\n    self.coords = np.dot(self.coords - centroid, rot.T) + centroid\n\n    # translation\n    self.coords = self.coords + trans\n\n    # update atomic coordinates\n    atom_idx = 0\n    for model in self.st:\n        for chain in model:\n            for residue in chain:\n                for atom in residue:\n                    atom.coord = self.coords[atom_idx,:]\n                    atom_idx += 1\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.update_coord","title":"<code>update_coord(coords)</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def update_coord(self, coords:np.ndarray) -&gt; None:\n    assert self.coords.shape == coords.shape, \"Matrix dimensions must match\"\n    # update atomic coordinates\n    atom_idx = 0\n    for model in self.st:\n        for chain in model:\n            for residue in chain:\n                for atom in residue:\n                    atom.coord = coords[atom_idx,:]\n                    atom_idx += 1\n</code></pre>"},{"location":"helper.html#mdscribe.helper.PDBfile.write","title":"<code>write(filename, model=None, chain=None, resname=None, resnumber=None)</code>","text":"<p>Write to PDB with selections.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pdb.write(model=[0], chain=['A'])\nwrite chain A and residues first-10,22-50,130-200,550,600-last\n&gt;&gt;&gt; pdb.write(chain=['A'], resnumber=\"-10,22-50,130-200,550,600-\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path</code> <p>output filename or path</p> required <code>model</code> <code>Optional[List[int]]</code> <p>list of model numbers. Defaults to None.</p> <code>None</code> <code>chain</code> <code>Optional[List[str]]</code> <p>list of chain ids. Defaults to None.</p> <code>None</code> <code>resname</code> <code>Optional[List[str]]</code> <p>list of residue names. Defaults to None.</p> <code>None</code> <code>resnumber</code> <code>Optional[str]</code> <p>residue number ranges. Defaults to None.</p> <code>None</code> Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def write(self, filename: str | Path, \n          model:Optional[List[int]] = None,\n          chain:Optional[List[str]] = None, \n          resname:Optional[List[str]] = None,\n          resnumber:Optional[str] = None,\n          ) -&gt; None:\n    \"\"\"Write to PDB with selections.\n\n    Examples:\n        &gt;&gt;&gt; pdb.write(model=[0], chain=['A'])\n        write chain A and residues first-10,22-50,130-200,550,600-last\n        &gt;&gt;&gt; pdb.write(chain=['A'], resnumber=\"-10,22-50,130-200,550,600-\")\n\n    Args:\n        filename (str | Path): output filename or path\n        model (Optional[List[int]], optional): list of model numbers. Defaults to None.\n        chain (Optional[List[str]], optional): list of chain ids. Defaults to None.\n        resname (Optional[List[str]], optional): list of residue names. Defaults to None.\n        resnumber (Optional[str], optional): residue number ranges. Defaults to None.\n    \"\"\"\n\n    io = PDBIO()\n\n    if (model is None) and (chain is None) and (resname is None) and (resnumber is None):\n        # write structure as it as\n        io.set_structure(self.st)\n    else: \n        # write only select model(s), chain(s) or residue(s)\n        # select residues by numbers\n        if resnumber is not None:\n            select_resseqs = [tuple(map(lambda s: int(s) if s else -1, r.split(\"-\"))) for r in resnumber.split(\",\")]\n            # for resnumber=\"-10,22-50,130-200,550,600-\"\n            # [(-1, 10), (22, 50), (130, 200), (550,), (600, -1)]\n        builder = StructureBuilder()\n        builder.init_structure(self.st.id)\n        for _model in self.st:\n            if (model is not None) and (_model.id not in model):\n                continue # reject model\n            builder.init_model(_model.id, serial_num=None)\n            for _chain in _model:\n                if (chain is not None) and (_chain.id not in chain):\n                    continue # reject chain\n                builder.init_chain(_chain.id)\n                for _residue in _chain:\n                    hetflag, resseq, iCode = _residue.get_id()\n                    if (resname is not None) and (_residue.resname not in resname):\n                        continue # reject residue by name\n                    # select residue numbers\n                    include_flags = []\n                    for lu in select_resseqs:\n                        if len(lu) == 1:\n                            if lu == resseq:\n                                include_flags.append(True)\n                            else:\n                                include_flags.append(False)\n                        else:\n                            (l,u) = lu\n                            if (l == -1 or l &lt;= resseq) and (u ==-1 or u &gt;= resseq):\n                                include_flags.append(True)\n                            else:\n                                include_flags.append(False)\n                    if not any(include_flags):\n                        continue # reject residue by number\n                    builder.init_residue(_residue.resname, hetflag, resseq, iCode)\n                    for atom in _residue:\n                        builder.init_atom(atom.name, \n                                        atom.coord, \n                                        atom.bfactor, \n                                        atom.occupancy,\n                                        atom.altloc,\n                                        atom.fullname,\n                                        None, # serial_number\n                                        atom.element,\n                                        )\n        io.set_structure(builder.get_structure())\n    with open(filename, \"w\") as f:\n        io.save(f)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.angle_between","title":"<code>angle_between(v1, v2)</code>","text":"<p>Returns the angle in radians between vectors 'v1' and 'v2'::</p> <p>angle_between((1, 0, 0), (0, 1, 0)) 1.5707963267948966 angle_between((1, 0, 0), (1, 0, 0)) 0.0 angle_between((1, 0, 0), (-1, 0, 0)) 3.141592653589793</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def angle_between(v1, v2):\n    \"\"\" Returns the angle in radians between vectors 'v1' and 'v2'::\n\n            &gt;&gt;&gt; angle_between((1, 0, 0), (0, 1, 0))\n            1.5707963267948966\n            &gt;&gt;&gt; angle_between((1, 0, 0), (1, 0, 0))\n            0.0\n            &gt;&gt;&gt; angle_between((1, 0, 0), (-1, 0, 0))\n            3.141592653589793\n    \"\"\"\n    v1_u = unit_vector(v1)\n    v2_u = unit_vector(v2)\n    rad = np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))\n    deg = rad*180./np.pi\n    if deg &gt; 90.0 :\n        deg = 180.0 - deg\n    return deg\n</code></pre>"},{"location":"helper.html#mdscribe.helper.avoid_clash","title":"<code>avoid_clash(fixed, movable, max_move=25.0, clash_cutoff=5.0, max_trials=1000)</code>","text":"<p>Find a translation vector for <code>movable</code> coordinates to avoid steric clashes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>ndarray</code> <p>coordinates to be fixed.</p> required <code>movable</code> <code>ndarry</code> <p>coordinates to be moved.</p> required <code>max_move</code> <code>float</code> <p>maximum translation. Defaults to 25.0.</p> <code>25.0</code> <code>clash_cutoff</code> <code>float</code> <p>distance considered as potential clash. Defaults to 5.0.</p> <code>5.0</code> <code>max_trials</code> <code>int</code> <p>maximum number of trials. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>(int, int, float, ndarray)</code> <p>(num_trials, clash_count, closest_dist, trans)</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def avoid_clash(fixed:np.ndarray, movable:np.ndarray, max_move:float=25.0, clash_cutoff:float=5.0, max_trials:int=1000) -&gt; Tuple[int, int, float, np.ndarray]:\n    \"\"\"Find a translation vector for `movable` coordinates to avoid steric clashes.\n\n    Args:\n        fixed (np.ndarray): coordinates to be fixed.\n        movable (np.ndarry): coordinates to be moved.\n        max_move (float, optional): maximum translation. Defaults to 25.0.\n        clash_cutoff (float, optional): distance considered as potential clash. Defaults to 5.0.\n        max_trials (int, optional): maximum number of trials. Defaults to 1000.\n\n    Returns:\n        (int,int,float,np.ndarray): (num_trials, clash_count, closest_dist, trans)\n    \"\"\"\n    kd = KDTree(fixed)\n    num_trials = 0\n    clash_count = 1\n    while clash_count &gt; 0 and num_trials &lt; max_trials:\n        num_trials += 1\n        trans = max_move * (2.0*np.random.rand(3) -1.0) \n        # numpy.random.rand() generates [0,1) so 2x-1 -&gt; [-1,+1)\n        coords = movable + trans\n        distances, indices = kd.query(coords)\n        clash_count = np.sum(distances &lt; clash_cutoff)\n        closest_dist = np.min(distances)\n    return (num_trials, clash_count, closest_dist, trans)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.download","title":"<code>download(PDBID, verbose=True)</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def download(PDBID:str, verbose:bool=True) -&gt; None:\n    pdb = pypdb.get_pdb_file(PDBID, filetype=\"pdb\")\n    filename = PDBID+\".pdb\"\n    if verbose:\n        print(\"downloading \",PDBID,\"as\", filename, end=\"\")\n    with open(filename,\"w\") as f:\n        f.write(pdb)\n        if verbose:\n            print(\"done\")\n</code></pre>"},{"location":"helper.html#mdscribe.helper.get_ligands","title":"<code>get_ligands(PDBID)</code>","text":"<p>Examples:</p> <pre><code>@structureId : 4KEB\n@chemicalID : 1QZ\n@type : non-polymer\n@molecularWeight : 423.51\nchemicalName : 6-ethyl-5-{(3S)-3-[3-(isoquinolin-5-yl)-5-methoxyphenyl]but-1-yn-1-yl}pyrimidine-2,4-diamine\nformula : C26 H25 N5 O\nInChI : InChI=1S/C26H25N5O/c1-4-24-23(25(27)31-26(28)30-24)9-8-16(2)18-12-19(14-20(13-18)32-3)21-7-5-6-17-15-29-11-10-22(17)21/h5-7,10-16H,4H2,1-3H3,(H4,27,28,30,31)/t16-/m1/s1\nInChIKey : MGLLCDAARSVGLO-MRXNPFEDSA-N\nsmiles : CCc1c(c(nc(n1)N)N)C#C[C@@H](C)c2cc(cc(c2)OC)c3cccc4c3ccnc4\n\n@structureId : 4KEB\n@chemicalID : FOL\n@type : non-polymer\n@molecularWeight : 441.397\nchemicalName : FOLIC ACID\nformula : C19 H19 N7 O6\nInChI : InChI=1S/C19H19N7O6/c20-19-25-15-14(17(30)26-19)23-11(8-22-15)7-21-10-3-1-9(2-4-10)16(29)24-12(18(31)32)5-6-13(27)28/h1-4,8,12,21H,5-7H2,(H,24,29)(H,27,28)(H,31,32)(H3,20,22,25,26,30)/t12-/m0/s1\nInChIKey : OVBPIULPVIDEAO-LBPRGKRZSA-N\nsmiles : c1cc(ccc1C(=O)N[C@@H](CCC(=O)O)C(=O)O)NCc2cnc3c(n2)C(=O)N=C(N3)N\n\n@structureId : 4KEB\n@chemicalID : NDP\n@type : non-polymer\n@molecularWeight : 745.421\nchemicalName : NADPH DIHYDRO-NICOTINAMIDE-ADENINE-DINUCLEOTIDE PHOSPHATE\nformula : C21 H30 N7 O17 P3\nInChIKey : ACFIXJIJDZMPPO-NNYOXOHSSA-N\nInChI : InChI=1S/C21H30N7O17P3/c22-17-12-19(25-7-24-17)28(8-26-12)21-16(44-46(33,34)35)14(30)11(43-21)6-41-48(38,39)45-47(36,37)40-5-10-13(29)15(31)20(42-10)27-3-1-2-9(4-27)18(23)32/h1,3-4,7-8,10-11,13-16,20-21,29-31H,2,5-6H2,(H2,23,32)(H,36,37)(H,38,39)(H2,22,24,25)(H2,33,34,35)/t10-,11-,13-,14-,15-,16-,20-,21-/m1/s1\nsmiles : c1nc(c2c(n1)n(cn2)[C@H]3[C@@H]([C@@H]([C@H](O3)CO[P@](=O)(O)O[P@@](=O)(O)OC[C@@H]4[C@H]([C@H]([C@@H](O4)N5C=CCC(=C5)C(=O)N)O)O)O)OP(=O)(O)O)N\n</code></pre> Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def get_ligands(PDBID:str) -&gt; None:\n    \"\"\"\n    Examples:\n\n        @structureId : 4KEB\n        @chemicalID : 1QZ\n        @type : non-polymer\n        @molecularWeight : 423.51\n        chemicalName : 6-ethyl-5-{(3S)-3-[3-(isoquinolin-5-yl)-5-methoxyphenyl]but-1-yn-1-yl}pyrimidine-2,4-diamine\n        formula : C26 H25 N5 O\n        InChI : InChI=1S/C26H25N5O/c1-4-24-23(25(27)31-26(28)30-24)9-8-16(2)18-12-19(14-20(13-18)32-3)21-7-5-6-17-15-29-11-10-22(17)21/h5-7,10-16H,4H2,1-3H3,(H4,27,28,30,31)/t16-/m1/s1\n        InChIKey : MGLLCDAARSVGLO-MRXNPFEDSA-N\n        smiles : CCc1c(c(nc(n1)N)N)C#C[C@@H](C)c2cc(cc(c2)OC)c3cccc4c3ccnc4\n\n        @structureId : 4KEB\n        @chemicalID : FOL\n        @type : non-polymer\n        @molecularWeight : 441.397\n        chemicalName : FOLIC ACID\n        formula : C19 H19 N7 O6\n        InChI : InChI=1S/C19H19N7O6/c20-19-25-15-14(17(30)26-19)23-11(8-22-15)7-21-10-3-1-9(2-4-10)16(29)24-12(18(31)32)5-6-13(27)28/h1-4,8,12,21H,5-7H2,(H,24,29)(H,27,28)(H,31,32)(H3,20,22,25,26,30)/t12-/m0/s1\n        InChIKey : OVBPIULPVIDEAO-LBPRGKRZSA-N\n        smiles : c1cc(ccc1C(=O)N[C@@H](CCC(=O)O)C(=O)O)NCc2cnc3c(n2)C(=O)N=C(N3)N\n\n        @structureId : 4KEB\n        @chemicalID : NDP\n        @type : non-polymer\n        @molecularWeight : 745.421\n        chemicalName : NADPH DIHYDRO-NICOTINAMIDE-ADENINE-DINUCLEOTIDE PHOSPHATE\n        formula : C21 H30 N7 O17 P3\n        InChIKey : ACFIXJIJDZMPPO-NNYOXOHSSA-N\n        InChI : InChI=1S/C21H30N7O17P3/c22-17-12-19(25-7-24-17)28(8-26-12)21-16(44-46(33,34)35)14(30)11(43-21)6-41-48(38,39)45-47(36,37)40-5-10-13(29)15(31)20(42-10)27-3-1-2-9(4-27)18(23)32/h1,3-4,7-8,10-11,13-16,20-21,29-31H,2,5-6H2,(H2,23,32)(H,36,37)(H,38,39)(H2,22,24,25)(H2,33,34,35)/t10-,11-,13-,14-,15-,16-,20-,21-/m1/s1\n        smiles : c1nc(c2c(n1)n(cn2)[C@H]3[C@@H]([C@@H]([C@H](O3)CO[P@](=O)(O)O[P@@](=O)(O)OC[C@@H]4[C@H]([C@H]([C@@H](O4)N5C=CCC(=C5)C(=O)N)O)O)O)OP(=O)(O)O)N\n    \"\"\"\n\n    ligandInfo = pypdb.get_ligands(PDBID)\n\n    try:    \n        ligands = ligandInfo[\"ligandInfo\"][\"ligand\"]\n    except:\n        ligands = []\n\n    for ligand_dict in ligands:\n        for k in ligand_dict:\n            print(\"%20s : %s\" % (k, ligand_dict[k]))\n\n    # chem_desc= pypdb.describe_chemical(PDBID)\n    # chem_desc[\"describeHet\"][\"ligandInfo\"][\"ligand\"][\"smiles\"]\n    # pdb_desc= pypdb.describe_pdb(\"5cgc\")\n    # pdb content as list of strings\n    data = {\n        \"name\": [],\n        \"smiles\": [],\n        \"molwt\": [],\n        \"chemical name\": [],\n        \"InChiKey\": [],\n        \"InChi\": [],\n    }\n    if \",\" in PDBID:\n        PDBID_list = PDBID.split(\",\")\n        for PDBID in PDBID_list:\n            for d in ligands:\n                try:\n                    data[\"name\"].append(d['@chemicalID'])\n                    data[\"smiles\"].append(d['smiles'])\n                    data[\"molwt\"].append(float(d['@molecularWeight']))\n                    data[\"chemical name\"].append(d['chemicalName'])\n                    data[\"InChiKey\"].append(d['InChIKey'])\n                    data[\"InChi\"].append(d['InChi'])\n                except:\n                    continue\n    else:\n        for d in ligands:\n            try:\n                data[\"name\"].append(d['@chemicalID'])\n                data[\"smiles\"].append(d['smiles'])\n                data[\"molwt\"].append(float(d['@molecularWeight']))\n                data[\"chemical name\"].append(d['chemicalName'])\n                data[\"InChiKey\"].append(d['InChIKey'])\n                data[\"InChi\"].append(d['InChi'])\n            except:\n                continue\n</code></pre>"},{"location":"helper.html#mdscribe.helper.hexagonal_grid","title":"<code>hexagonal_grid()</code>","text":"<p>Generate XY coordinates of hexagonal grid for membrane MD simulations.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: (x,y) coordinates</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def hexagonal_grid() -&gt; np.ndarray:\n    \"\"\"Generate XY coordinates of hexagonal grid for membrane MD simulations.\n\n    Returns:\n        np.ndarray: (x,y) coordinates\n    \"\"\"\n    theta = np.radians(60)\n    c, s = np.cos(theta), np.sin(theta)\n    R = np.array([[c, -s], [s, c]])\n\n    d = 50.0\n    grid = {0: [ np.array([0,0]) ] }\n    for shell in [1, 2]:\n        v = np.array([0.0, d*shell])\n        grid[shell] = [v]\n        for i in range(0, 5):\n            v = np.dot(R, v)\n            if shell &gt; 1:\n                delta = (grid[shell][-1] - v)/shell\n                for j in range(1, shell):\n                    grid[shell].append(j*delta + v)\n            grid[shell].append(v)\n        if shell &gt; 1:\n            v = np.dot(R, v)\n            delta = (grid[shell][-1] - v)/shell\n            for j in range(1, shell):\n                grid[shell].append(j*delta + v)\n        grid[shell].append(v)\n\n    xy = []\n    for shell in grid:\n        for item in grid[shell] :\n            x_, y_ = item\n            xy.append([x_, y_])\n    return np.array(xy)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.kabsch_algorithm","title":"<code>kabsch_algorithm(P, Q)</code>","text":"<p>Computes the optimal rotation and translation to align two sets of points (P -&gt; Q), and their RMSD.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; P = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]])\n&gt;&gt;&gt; Q = np.array([[1, 1, 0], [2, 1, 0], [1, 2, 0]])\n&gt;&gt;&gt; # Q is translated by (1,1,0) \n&gt;&gt;&gt; (rot, trans, rmsd) = kabsch_transform(P, Q)\n&gt;&gt;&gt; transform(P, rot, trans)\n</code></pre> <pre><code>&gt;&gt;&gt; P = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n&gt;&gt;&gt; Q = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n&gt;&gt;&gt; # Q is a 90-degree rotation of P around the z-axis\n&gt;&gt;&gt; (rot, trans, rmsd) = kabsch_transform(P, Q)\n&gt;&gt;&gt; transform(P, rot, trans)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>ndarray</code> <p>subject coordinates. Not modified.</p> required <code>Q</code> <code>ndarray</code> <p>target coordinates. Not modified.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray, float]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray, float]: A tuple containing the optimal rotation matrix, the optimal translation vector, the centroid of P, and the RMSD.</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def kabsch_algorithm(P:np.ndarray, Q:np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, float]:\n    \"\"\"Computes the optimal rotation and translation to align two sets of points (P -&gt; Q),\n    and their RMSD.\n\n    Examples:\n        &gt;&gt;&gt; P = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]])\n        &gt;&gt;&gt; Q = np.array([[1, 1, 0], [2, 1, 0], [1, 2, 0]])\n        &gt;&gt;&gt; # Q is translated by (1,1,0) \n        &gt;&gt;&gt; (rot, trans, rmsd) = kabsch_transform(P, Q)\n        &gt;&gt;&gt; transform(P, rot, trans)\n\n        &gt;&gt;&gt; P = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        &gt;&gt;&gt; Q = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n        &gt;&gt;&gt; # Q is a 90-degree rotation of P around the z-axis\n        &gt;&gt;&gt; (rot, trans, rmsd) = kabsch_transform(P, Q)\n        &gt;&gt;&gt; transform(P, rot, trans)\n\n    Args:\n        P (np.ndarray): subject coordinates. Not modified.\n        Q (np.ndarray): target coordinates. Not modified.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, float]: A tuple containing the optimal rotation matrix, the optimal\n            translation vector, the centroid of P, and the RMSD.\n    \"\"\"\n\n    assert P.shape == Q.shape, \"Matrix dimensions must match\"\n\n    # Compute centroids\n    centroid_P = np.mean(P, axis=0)\n    centroid_Q = np.mean(Q, axis=0)\n\n    # Optimal translation\n    t = centroid_Q - centroid_P\n\n    # Center the points\n    p = P - centroid_P\n    q = Q - centroid_Q\n\n    # Compute the covariance matrix\n    H = np.dot(p.T, q)\n\n    # SVD\n    U, S, Vt = np.linalg.svd(H)\n    V = Vt.T\n    d = np.linalg.det(np.dot(V, U.T))\n    e = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, d]])\n\n    # Optimal rotation\n    R = np.dot(np.dot(V, e), U.T)\n\n    # RMSD\n    rmsd = np.sqrt(np.sum(np.square(np.dot(p, R.T) - q)) / P.shape[0])\n\n    return (R, t, centroid_P, rmsd)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.pca","title":"<code>pca(X)</code>","text":"Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def pca(X):\n    # Data matrix X\n    n, m = X.shape\n    centroid = X.mean(axis=0)\n    X = X - centroid # make it 0-centered\n    assert np.allclose(X.mean(axis=0), np.zeros(m), atol=1e-5)\n    # Compute covariance matrix\n    C = np.dot(X.T, X) / (n-1)\n    # Eigen decomposition\n    eigen_vals, eigen_vecs = np.linalg.eig(C)\n    # Project X onto PC space\n    # X_pca = np.dot(X, eigen_vecs)\n    return eigen_vecs\n</code></pre>"},{"location":"helper.html#mdscribe.helper.quaternion_to_rotation_matrix","title":"<code>quaternion_to_rotation_matrix(Q)</code>","text":"<p>Covert a quaternion into a full three-dimensional rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>List[float]</code> <p>A 4 element array representing the quaternion (q0,q1,q2,q3)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A 3x3 element matrix representing the full 3D rotation matrix.  This rotation matrix converts a point in the local reference frame  to a point in the global reference frame.</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def quaternion_to_rotation_matrix(Q:List[float]) -&gt; np.ndarray:\n    \"\"\"Covert a quaternion into a full three-dimensional rotation matrix.\n\n    Args:\n        Q (List[float]): A 4 element array representing the quaternion (q0,q1,q2,q3)\n\n    Returns:\n        np.ndarray: A 3x3 element matrix representing the full 3D rotation matrix. \n            This rotation matrix converts a point in the local reference frame \n            to a point in the global reference frame.\n    \"\"\"\n\n    # Extract the values from Q\n    q0 = Q[0]\n    q1 = Q[1]\n    q2 = Q[2]\n    q3 = Q[3]\n\n    # First row of the rotation matrix\n    r00 = 2 * (q0 * q0 + q1 * q1) - 1\n    r01 = 2 * (q1 * q2 - q0 * q3)\n    r02 = 2 * (q1 * q3 + q0 * q2)\n\n    # Second row of the rotation matrix\n    r10 = 2 * (q1 * q2 + q0 * q3)\n    r11 = 2 * (q0 * q0 + q2 * q2) - 1\n    r12 = 2 * (q2 * q3 - q0 * q1)\n\n    # Third row of the rotation matrix\n    r20 = 2 * (q1 * q3 - q0 * q2)\n    r21 = 2 * (q2 * q3 + q0 * q1)\n    r22 = 2 * (q0 * q0 + q3 * q3) - 1\n\n    # 3x3 rotation matrix, R\n    R = np.array([[r00, r01, r02],\n                           [r10, r11, r12],\n                           [r20, r21, r22]])\n\n    return R\n</code></pre>"},{"location":"helper.html#mdscribe.helper.random_rotation_matrix","title":"<code>random_rotation_matrix()</code>","text":"<p>Generate a random rotational matrix.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>random (3,3) matrix</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def random_rotation_matrix() -&gt; np.ndarray:\n    \"\"\"Generate a random rotational matrix.\n\n    Returns:\n        ndarray : random (3,3) matrix\n    \"\"\"\n    axis = np.random.randn(3)\n    axis /= np.linalg.norm(axis)\n\n    angle = random.uniform(0, 2 * np.pi)\n    # Build the rotation matrix using Rodrigues' formula\n    K = np.array([[0, -axis[2], axis[1]],\n                  [axis[2], 0, -axis[0]],\n                  [-axis[1], axis[0], 0]])\n    R = np.eye(3) + np.sin(angle) * K + (1 - np.cos(angle)) * np.dot(K, K)\n\n    return R\n</code></pre>"},{"location":"helper.html#mdscribe.helper.random_translation_vector","title":"<code>random_translation_vector(lower=0.0, upper=1.0)</code>","text":"<p>Generate a random translational vector.</p> <p>Parameters:</p> Name Type Description Default <code>lower</code> <code>float) </code> <p>lower bound. Defaults to 0.0</p> <code>0.0</code> <code>upper</code> <code>float) </code> <p>upper bound. Defaults to 1.0</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: random (3,) vector</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def random_translation_vector(lower:float=0.0, upper:float=1.0) -&gt; np.ndarray:\n    \"\"\"Generate a random translational vector.\n\n    Args:\n        lower (float) : lower bound. Defaults to 0.0\n        upper (float) : upper bound. Defaults to 1.0\n\n    Returns:\n        np.ndarray: random (3,) vector\n    \"\"\"\n    rng = np.random.default_rng()\n    return rng.uniform(lower, upper, size=3)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.renumber","title":"<code>renumber(residue)</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def renumber(residue:Optional[dict]):\n    pass\n</code></pre>"},{"location":"helper.html#mdscribe.helper.reorient","title":"<code>reorient()</code>","text":"Source code in <code>mdscribe/helper/pdbfile.py</code> <pre><code>def reorient():\n    argparser = argparse.ArgumentParser(description='Reorient PDB')\n    argparser.add_argument(\"filename\", help=\"pdb filename\")\n    argparser.add_argument(\"--inverse-z\", dest=\"inverse_z_axis\", help=\"inverse z axis\", default=False, action=\"store_true\")\n    argparser.add_argument(\"--residue\", help=\"residues for principal axes calc. ex. A:23-50,B:1-90\", default=\"\")\n    argparser.add_argument(\"--offset-x\", dest=\"offset_x\", help=\"translate x coordinates\", type=float, default=0.0)\n    argparser.add_argument(\"--offset-y\", dest=\"offset_y\", help=\"translate y coordinates\", type=float, default=0.0)\n    argparser.add_argument(\"--offset-z\", dest=\"offset_z\", help=\"translate z coordinates\", type=float, default=0.0)\n    argparser.add_argument(\"--segid\", dest=\"segId\", help=\"override segment id\", default=\"\")\n    argparser.add_argument(\"--chainid\", dest=\"chainId\", help=\"override chain id\", default=\"\")\n    args = argparser.parse_args()\n\n    # subset of atoms for Eigenvector/Eigenvalue calculations\n    subset_atoms = []\n    if args.residue:\n        for chain in args.residue.split(\",\"):\n            (chainId, resSeq_range) = chain.split(\":\")\n            (resSeq_begin, resSeq_end) = resSeq_range.split(\"-\")\n            subset_atoms.append((chainId, int(resSeq_begin), int(resSeq_end)))\n\n    with open(args.filename, \"r\") as pdb_file:\n        xyz = []\n        for line in pdb_file:\n            if line.startswith('ATOM') or line.startswith('HETATM'):\n                chainId = line[21:22]\n                resSeq = int(line[22:26])\n                if subset_atoms:\n                    for chainId_, resSeq_begin, resSeq_end in subset_atoms:\n                        if not (chainId == chainId_ and resSeq &gt;= resSeq_begin and resSeq &lt;= resSeq_end):\n                            continue\n                x = float(line[30:38].strip())\n                y = float(line[38:46].strip())\n                z = float(line[46:54].strip())\n                xyz.append([x,y,z])\n\n        print(\"REMARK reoriented according to its principal axes\")\n        if args.residue:\n            print(f\"REMARK principal axes are calculated using --residue {args.residue}\")\n        print(f\"REMARK coordinates from {args.filename} ({len(xyz)} atoms)\")\n        if args.inverse_z_axis:\n            print(\"REMARK Z axis inverted\")\n        print(f\"REMARK coordinates offset X {args.offset_x:8.3f} Y {args.offset_x:8.3f} Z {args.offset_x:8.3f}\")\n\n        coord = np.array(xyz, float)\n\n        # geometric center\n        center = np.mean(coord, 0)\n        box_min = np.min(coord, 0)\n        box_max = np.max(coord, 0)\n        print(\"REMARK geometric center:\", center)\n        print(\"REMARK coordinate range:\", box_min, box_max)\n        print(\"REMARK box size:\", box_max-box_min)\n\n        coord = coord - center\n\n        # compute principal axis matrix\n        inertia = np.dot(coord.transpose(), coord)\n        w,v = np.linalg.eig(inertia)\n\n        # warning eigen values are not necessary ordered!\n        # http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html\n        #--------------------------------------------------------------------------\n        # order eigen values (and eigen vectors)\n        #\n        # axis1 is the principal axis with the biggest eigen value (eval1)\n        # axis2 is the principal axis with the second biggest eigen value (eval2)\n        # axis3 is the principal axis with the smallest eigen value (eval3)\n        #--------------------------------------------------------------------------\n        # axis1 --&gt; Z\n        # axis2 --&gt; Y\n        # axis3 --&gt; X\n        order = np.argsort(w)\n        eval3, eval2, eval1 = w[order]\n        axis3, axis2, axis1 = v[:, order]\n\n        print(\"REMARK x-axis\",axis3,\"eval=\",eval3)\n        print(\"REMARK y-axis\",axis2,\"eval=\",eval2)\n        print(\"REMARK z-axis\",axis1,\"eval=\",eval1)\n\n        R = np.array([axis3, axis2, axis1]) # decreasing order\n        R_inv = np.linalg.inv(R)\n\n        pdb_file.seek(0)\n        for line in pdb_file:\n            if not line: continue\n            if line.startswith('ATOM') or line.startswith('HETATM'):\n                x = float(line[30:38].strip())\n                y = float(line[38:46].strip())\n                z = float(line[46:54].strip())\n                xyz = np.array([x,y,z])\n                xyz = xyz - center\n                xyz = np.dot(R_inv, xyz)\n                x, y, z = xyz\n                if args.inverse_z_axis:\n                    z = -z\n                x += args.offset_x\n                y += args.offset_y\n                z += args.offset_z\n\n                # keep the rest of information as they are\n                line = line[:30] + \"%8.3f%8.3f%8.3f\" % (x, y, z) + line[54:]\n\n                # override chain id\n                if args.chainId:\n                    line = line[:21] + \"%1s\" % args.chainId + line[22:]\n\n                # override segment id\n                if args.segId:\n                    line = line[:72] + \"%4s\" % args.segId + line[76:]\n\n                print(line, end='')\n            else:\n                print(line, end='')\n</code></pre>"},{"location":"helper.html#mdscribe.helper.test_kabsch_algorithm","title":"<code>test_kabsch_algorithm(trials=100, rtol=1e-05, atol=1e-08)</code>","text":"Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def test_kabsch_algorithm(trials:int=100, rtol:float=1e-5, atol:float=1e-8) -&gt; None:\n    results = []\n    for i in range(trials):\n        rot = random_rotation_matrix()\n        trans = random_translation_vector(0.0, 50.0)\n        # generate a 10x3 array with random floats between 0 and 1\n        P = np.random.rand(10, 3) * 100.0\n        Q = transform(P, rot, trans)\n        (rot_, trans_, centroid_, rmsd_) = kabsch_algorithm(P, Q)\n        res = np.allclose(rot, rot_, rtol=rtol, atol=atol) and np.allclose(trans, trans_, rtol=rtol, atol=atol)\n        results.append(res)\n    if all(results):\n        print(\"pass\")\n    else:\n        print(\"failed\")\n</code></pre>"},{"location":"helper.html#mdscribe.helper.transform","title":"<code>transform(P, centroid=np.array([0.0, 0.0, 0.0]), rot=np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]), trans=np.array([0.0, 0.0, 0.0]))</code>","text":"<p>Rotate and translate input coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>ndarray</code> <p>input coordinates.</p> required <code>centroid</code> <code>ndarray</code> <p>centroid. Defaults to np.array([0., 0., 0.])</p> <code>array([0.0, 0.0, 0.0])</code> <code>rot</code> <code>ndarray</code> <p>rotation matrix. Defaults to np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]]).</p> <code>array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])</code> <code>trans</code> <code>ndarray</code> <p>translation vector. Defaults to np.array([0., 0., 0.]).</p> <code>array([0.0, 0.0, 0.0])</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: transformed output coordinates.</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def transform(P:np.ndarray,\n              centroid:np.ndarray = np.array([0., 0., 0.]),\n              rot:np.ndarray = np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]]), \n              trans:np.ndarray = np.array([0., 0., 0.])) -&gt; np.ndarray:\n    \"\"\"Rotate and translate input coordinates.\n\n    Args:\n        P (np.ndarray): input coordinates.\n        centroid (np.ndarray, optional): centroid. Defaults to np.array([0., 0., 0.])\n        rot (np.ndarray, optional): rotation matrix. Defaults to np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]]).\n        trans (np.ndarray, optional): translation vector. Defaults to np.array([0., 0., 0.]).\n\n    Returns:\n        np.ndarray: transformed output coordinates.\n    \"\"\"\n    Q = np.dot(P-centroid, rot.T) + centroid + trans\n    return Q\n</code></pre>"},{"location":"helper.html#mdscribe.helper.unit_vector","title":"<code>unit_vector(vector)</code>","text":"<p>Returns the unit vector of the vector.</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def unit_vector(vector):\n    \"\"\" Returns the unit vector of the vector.  \"\"\"\n    return vector / np.linalg.norm(vector)\n</code></pre>"},{"location":"helper.html#mdscribe.helper.view_svg","title":"<code>view_svg(rdmol, highlight=[], width=300, height=300)</code>","text":"<p>SVG depiction for the Jupyter Notebook.</p> Reference <p>https://www.linkedin.com/pulse/using-rdkit-jupyter-notebooks-lee-davies/</p> <p>Parameters:</p> Name Type Description Default <code>rdmol</code> <code>Mol</code> <p>rdkit molecule.</p> required <code>highlight</code> <code>list</code> <p>highlighted atom indexes. Defaults to [].</p> <code>[]</code> <code>width</code> <code>int</code> <p>width. Defaults to 300.</p> <code>300</code> <code>height</code> <code>int</code> <p>height. Defaults to 300.</p> <code>300</code> Source code in <code>mdscribe/helper/svg.py</code> <pre><code>def view_svg(rdmol:Chem.Mol, highlight=[], width=300, height=300):\n    \"\"\"SVG depiction for the Jupyter Notebook.\n\n    Reference:\n        https://www.linkedin.com/pulse/using-rdkit-jupyter-notebooks-lee-davies/\n\n    Args:\n        rdmol (Chem.Mol): rdkit molecule.\n        highlight (list, optional): highlighted atom indexes. Defaults to [].\n        width (int, optional): width. Defaults to 300.\n        height (int, optional): height. Defaults to 300.\n    \"\"\"\n    rdmol2d = Chem.Mol(rdmol)\n    AllChem.Compute2DCoords(rdmol2d)\n    drawer = rdMolDraw2D.MolDraw2DSVG(width, height)\n    drawer.DrawMolecule(rdmol2d, highlightAtoms=highlight)\n    drawer.FinishDrawing()\n    svg = drawer.GetDrawingText()\n    display(SVG(svg.replace(\"svg:\",\"\")))\n</code></pre>"},{"location":"openmm.html","title":"OpenMM","text":""},{"location":"openmm.html#mdscribe.openmm","title":"<code>mdscribe.openmm</code>","text":""},{"location":"openmm.html#mdscribe.openmm.__all__","title":"<code>__all__ = ['prepare_simulation', 'simulate_states', 'run_equilibration']</code>  <code>module-attribute</code>","text":""},{"location":"openmm.html#mdscribe.openmm.prepare_simulation","title":"<code>prepare_simulation(system, topology, state, coords, config, platform)</code>","text":"<p>Prepare an OpenMM simulation object ready for a given stage.</p> Source code in <code>mdscribe/openmm/simulate.py</code> <pre><code>def prepare_simulation(\n    system: openmm.System,\n    topology: parmed.Structure,\n    state: dict[str, float],\n    coords: openmm.State | None,\n    config: femto.md.config.SimulationStage,\n    platform: femto.md.constants.OpenMMPlatform,\n    ) -&gt; openmm.app.Simulation:\n    \"\"\"Prepare an OpenMM simulation object ready for a given stage.\"\"\"\n    system = copy.deepcopy(system)\n\n    for mask, restraint in config.restraints.items():\n        system.addForce(\n            femto.md.restraints.create_position_restraints(topology, mask, restraint)\n        )\n    if isinstance(config, femto.md.config.Simulation) and config.pressure is not None:\n        barostat = openmm.MonteCarloBarostat(\n            config.pressure, config.temperature, config.barostat_frequency\n        )\n        system.addForce(barostat)\n\n    if isinstance(config, femto.md.config.Anneal):\n        integrator = femto.md.utils.openmm.create_integrator(\n            config.integrator, config.temperature_initial\n        )\n    elif isinstance(config, femto.md.config.Simulation):\n        integrator = femto.md.utils.openmm.create_integrator(\n            config.integrator, config.temperature\n        )\n    else:\n        integrator = openmm.VerletIntegrator(0.0001)\n\n    femto.md.utils.openmm.assign_force_groups(system)\n\n    simulation = femto.md.utils.openmm.create_simulation(\n        system, topology, coords, integrator, state, platform\n    )\n    return simulation\n</code></pre>"},{"location":"openmm.html#mdscribe.openmm.run_equilibration","title":"<code>run_equilibration(system, parmedstruct, statedict, stages, platform=femto.md.constants.OpenMMPlatform.CUDA, enforce_pbc=False, workdir=pathlib.Path('.'), destdir=None, save_prefix='equi', save_checkpoint=True, save_state=True, save_coord=True)</code>","text":"<p>Simulate a system following the specified <code>stages</code>, at a given 'state' (i.e. a set of context parameters, such as free energy lambda values)</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>system to simulate</p> required <code>parmedstruct</code> <code>Structure</code> <p>topology (parameters + coordinates) to simulate</p> required <code>statedict</code> <code>dict[str, float]</code> <p>state dictionary</p> required <code>stages</code> <code>list[SimulationStage]</code> <p>stages for equilibration</p> required <code>platform</code> <code>OpenMMPlatform</code> <p>computing platform. Defaults to CUDA.</p> <code>CUDA</code> <code>enforce_pbc</code> <code>bool</code> <p>whether to enforce periodic boundary condition for final coordinates. Defaults to False.</p> <code>False</code> <code>save_checkpoint</code> <code>Path | None</code> <p>save checkpoint (.cpt). Defaults to None.</p> <code>True</code> <code>save_state</code> <code>Path | None</code> <p>save state (.xml). Defaults to None.</p> <code>True</code> <code>save_coord</code> <code>Path | None</code> <p>save coordinates (.rst7). Defaults to None.</p> <code>True</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>unknown stage type</p> <p>Returns:</p> Type Description <code>State</code> <p>openmm.State: final openmm state (position, velocity, force, energy)</p> NVT annealing <p>When performing a simulated annealing process in an OpenMM molecular dynamics simulation,  it is generally recommended to use the NVT ensemble (constant number of particles, volume, and temperature),  as this allows for precise control of the system's temperature throughout the heating and cooling stages,  which is crucial for a successful annealing procedure.</p> Source code in <code>mdscribe/openmm/simulate.py</code> <pre><code>def run_equilibration(\n    system: openmm.System,\n    parmedstruct: parmed.Structure,\n    statedict: dict[str, float],\n    stages: list[femto.md.config.SimulationStage],\n    platform: femto.md.constants.OpenMMPlatform = femto.md.constants.OpenMMPlatform.CUDA,\n    enforce_pbc: bool = False,\n    workdir: pathlib.Path | None = pathlib.Path(\".\"),\n    destdir: pathlib.Path | None = None,\n    save_prefix: str = \"equi\",\n    save_checkpoint: bool = True,\n    save_state: bool = True,\n    save_coord: bool = True,\n    ) -&gt; openmm.State:\n    \"\"\"Simulate a system following the specified ``stages``, at a given 'state' (i.e.\n    a set of context parameters, such as free energy lambda values)\n\n    Args:\n        system (openmm.System): system to simulate\n        parmedstruct (parmed.Structure): topology (parameters + coordinates) to simulate\n        statedict (dict[str, float]): state dictionary\n        stages (list[femto.md.config.SimulationStage]): stages for equilibration\n        platform (femto.md.constants.OpenMMPlatform): computing platform. Defaults to CUDA.\n        enforce_pbc (bool, optional): whether to enforce periodic boundary condition for final coordinates. Defaults to False.\n        save_checkpoint (pathlib.Path | None, optional): save checkpoint (.cpt). Defaults to None.\n        save_state (pathlib.Path | None, optional): save state (.xml). Defaults to None.\n        save_coord (pathlib.Path | None, optional): save coordinates (.rst7). Defaults to None.\n\n    Raises:\n        NotImplementedError: unknown stage type\n\n    Returns:\n        openmm.State: final openmm state (position, velocity, force, energy)\n\n    NVT annealing:\n        When performing a simulated annealing process in an OpenMM molecular dynamics simulation, \n        it is generally recommended to use the NVT ensemble (constant number of particles, volume, and temperature), \n        as this allows for precise control of the system's temperature throughout the heating and cooling stages, \n        which is crucial for a successful annealing procedure.\n    \"\"\"\n\n    try:\n        workdir.mkdir(parents=True, exist_ok=True)\n    except:\n        print(f\"cannot create given workdir: {workdir}\")\n        sys.exit(0)\n\n    log_filename = f'{save_prefix}.log'\n    checkpoint_filename = f'{save_prefix}.cpt'\n    state_filename = f'{save_prefix}.xml'\n    rst7_filename = f'{save_prefix}.rst7'\n    prmtop_filename = f'{save_prefix}.prmtop'\n\n    logging.basicConfig(filename= (workdir / log_filename).as_posix(),\n                        filemode='w',\n                        format='%(asctime)s:%(levelname)s:%(name)s:%(message)s',\n                        datefmt='%Y-%m-%d %H:%M',\n                        level=logging.INFO)\n\n    reporters = [\n        openmm.app.statedatareporter.StateDataReporter(\n            sys.stdout, \n            reportInterval=1000, \n            step=True, \n            time=True,\n            potentialEnergy=True, \n            temperature=True, \n            volume=True, \n            density=True,\n            ),\n        openmm.app.statedatareporter.StateDataReporter(\n            (workdir / log_filename).as_posix(), \n            reportInterval=1000, \n            step=True, \n            time=True,\n            potentialEnergy=True, \n            temperature=True, \n            volume=True, \n            density=True,\n            ),\n    ]\n\n    stage_state = None\n    for stage in stages:\n        simulation = prepare_simulation(system, parmedstruct, statedict, stage_state, stage, platform)\n        for reporter in reporters:\n            simulation.reporters.append(reporter)\n\n        if isinstance(stage, femto.md.config.Minimization):   \n            simulation.minimizeEnergy(\n                stage.tolerance.value_in_unit(\n                    openmm.unit.kilojoules_per_mole / openmm.unit.nanometer\n                    ), \n                stage.max_iterations\n            )\n        elif isinstance(stage, femto.md.config.Anneal):\n            femto.md.anneal.anneal_temperature(\n                simulation,\n                stage.temperature_initial,\n                stage.temperature_final,\n                stage.n_steps,\n                stage.frequency,\n            )\n        elif isinstance(stage, femto.md.config.Simulation):\n            simulation.step(stage.n_steps)\n        else:\n            raise NotImplementedError(f\"unknown stage type {type(stage)}\")\n\n        _LOGGER.info(f\"{femto.md.utils.openmm.get_simulation_summary(simulation)}\")\n\n        stage_state = simulation.context.getState(\n            getPositions=True,\n            getVelocities=True,\n            getForces=True,\n            getEnergy=True,\n            enforcePeriodicBox=enforce_pbc,\n        )\n\n    if save_checkpoint:\n        with open(workdir / checkpoint_filename, \"wb\") as file:\n            simulation.saveCheckpoint(file)\n\n    if save_state:\n        with open(workdir / state_filename, \"w\") as file:\n            simulation.saveState(file)\n\n    if save_coord:\n        _parmedstruct = copy.deepcopy(parmedstruct)\n        _parmedstruct.coordinates = stage_state.getPositions(asNumpy=True)\n        _parmedstruct.save((workdir / rst7_filename).as_posix(), overwrite=True)\n        _parmedstruct.save((workdir / prmtop_filename).as_posix(), overwrite=True)\n\n    # copy output files in the `workdir` to the `destdir``\n    if destdir is not None:\n        destdir.mkdir(parents=True, exist_ok=True)\n        shutil.copy(workdir / log_filename, destdir)\n        if save_checkpoint:\n            shutil.copy(workdir / checkpoint_filename, destdir)\n        if save_state:\n            shutil.copy(workdir / state_filename, destdir)\n        if save_coord:\n            shutil.copy(workdir / rst7_filename, destdir)\n\n    return stage_state\n</code></pre>"},{"location":"openmm.html#mdscribe.openmm.simulate_states","title":"<code>simulate_states(spark, system, topology, states, stages, platform, reporter=None, enforce_pbc=False)</code>","text":"<p>Launching Apache Spark jobs to run multi-stage simulations of each state.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The system to simulate.</p> required <code>topology</code> <code>Structure</code> <p>The topology of the system to simulate.</p> required <code>states</code> <code>list[dict[str, float]]</code> <p>The states of the system to simulate.</p> required <code>stages</code> <code>list[SimulationStage]</code> <p>The stages to run.</p> required <code>platform</code> <code>OpenMMPlatform</code> <p>The accelerator to use.</p> required <code>reporter</code> <code>OpenMMStateReporter | None</code> <p>The reporter to use to record system statistics such as volume and energy.</p> <code>None</code> <code>enforce_pbc</code> <code>bool</code> <p>Whether to enforce periodic boundary conditions when retrieving the final coordinates.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[State]</code> <p>The final coordinates at each state.</p> Source code in <code>mdscribe/openmm/simulate.py</code> <pre><code>def simulate_states(\n    spark: pyspark.sql.session.SparkSession,\n    system: openmm.System,\n    topology: parmed.Structure,\n    states: list[dict[str, float]],\n    stages: list[femto.md.config.SimulationStage],\n    platform: femto.md.constants.OpenMMPlatform,\n    reporter: femto.md.reporting.openmm.OpenMMStateReporter | None = None,\n    enforce_pbc: bool = False,\n    ) -&gt; list[openmm.State]:\n    \"\"\"Launching Apache Spark jobs to run multi-stage simulations of each state.\n\n    Args:\n        system: The system to simulate.\n        topology: The topology of the system to simulate.\n        states: The states of the system to simulate.\n        stages: The stages to run.\n        platform: The accelerator to use.\n        reporter: The reporter to use to record system statistics such as volume and\n            energy.\n        enforce_pbc: Whether to enforce periodic boundary conditions when retrieving\n            the final coordinates.\n\n    Returns:\n        The final coordinates at each state.\n    \"\"\"\n    state_indexes = list(range(len(states)))\n    _partial_spark_simulate_state = functools.partial(\n        simulate_state_index,\n        system=system, # &lt;-- serializable\n        topology=topology, # &lt;-- serializable\n        states=states, # &lt;-- list of dictionaries\n        stages=stages,\n        platform=platform,\n        reporter=reporter,\n        enforce_pbc=enforce_pbc,\n        )\n    rdd = spark.sparkContext.parallelize(state_indexes)\n    results = rdd.map(_partial_spark_simulate_state).collect()\n    return results \n</code></pre>"},{"location":"ternary.html","title":"Ternary Complex","text":""},{"location":"ternary.html#mdscribe.ternary","title":"<code>mdscribe.ternary</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ligand","title":"<code>Ligand</code>  <code>dataclass</code>","text":"<p>Class for ligand information.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>@dataclass\nclass Ligand:\n    \"\"\"Class for ligand information.\"\"\"\n    st: parmed.structure.Structure\n    idx0: List[int] = field(default_factory=list) # all atoms\n    idx: List[int] = field(default_factory=list) # non-hydrogens\n    imap: Dict[int,int] = field(default_factory=dict) # pdb atom idx -&gt; st atom idx\n    mol: Chem.Mol | None = None\n    highlight: List[int] = field(default_factory=list)\n\n    def coor(self) -&gt; np.ndarray:\n        return self.st.coordinates[self.idx,:]\n\n    def centroid(self) -&gt; np.ndarray:\n        return np.mean(self.coor(), axis=0)\n\n    def name(self) -&gt; List[str]:\n        return [self.st.atoms[i].name for i in self.idx ]\n\n    def atomic_number(self) -&gt; List[int]:\n        return [self.st.atoms[i].atomic_number for i in self.idx ]\n\n    def residue_name(self) -&gt; List[str]:\n        return [self.st.atoms[i].residue.name for i in self.idx ]\n\n    def residue_number(self) -&gt; List[int]:\n        return [self.st.atoms[i].residue.number for i in self.idx ]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ligand.highlight","title":"<code>highlight = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ligand.idx","title":"<code>idx = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ligand.idx0","title":"<code>idx0 = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ligand.imap","title":"<code>imap = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ligand.mol","title":"<code>mol = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ligand.st","title":"<code>st</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ligand.__init__","title":"<code>__init__(st, idx0=list(), idx=list(), imap=dict(), mol=None, highlight=list())</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ligand.atomic_number","title":"<code>atomic_number()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def atomic_number(self) -&gt; List[int]:\n    return [self.st.atoms[i].atomic_number for i in self.idx ]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ligand.centroid","title":"<code>centroid()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def centroid(self) -&gt; np.ndarray:\n    return np.mean(self.coor(), axis=0)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ligand.coor","title":"<code>coor()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def coor(self) -&gt; np.ndarray:\n    return self.st.coordinates[self.idx,:]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ligand.name","title":"<code>name()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def name(self) -&gt; List[str]:\n    return [self.st.atoms[i].name for i in self.idx ]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ligand.residue_name","title":"<code>residue_name()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def residue_name(self) -&gt; List[str]:\n    return [self.st.atoms[i].residue.name for i in self.idx ]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ligand.residue_number","title":"<code>residue_number()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def residue_number(self) -&gt; List[int]:\n    return [self.st.atoms[i].residue.number for i in self.idx ]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Molecule","title":"<code>Molecule</code>  <code>dataclass</code>","text":"<p>Class for protein information.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>@dataclass\nclass Molecule:\n    \"\"\"Class for protein information.\"\"\"\n    st: parmed.structure.Structure\n    idx: List[int] = field(default_factory=list)\n\n    def coor(self) -&gt; np.ndarray:\n        return self.st.coordinates[self.idx,:]\n\n    def centroid(self) -&gt; np.ndarray:\n        return np.mean(self.coor(), axis=0)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Molecule.idx","title":"<code>idx = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Molecule.st","title":"<code>st</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Molecule.__init__","title":"<code>__init__(st, idx=list())</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Molecule.centroid","title":"<code>centroid()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def centroid(self) -&gt; np.ndarray:\n    return np.mean(self.coor(), axis=0)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Molecule.coor","title":"<code>coor()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def coor(self) -&gt; np.ndarray:\n    return self.st.coordinates[self.idx,:]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Pocket","title":"<code>Pocket</code>  <code>dataclass</code>","text":"<p>Class for pocket information.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>@dataclass\nclass Pocket:\n    \"\"\"Class for pocket information.\"\"\"\n    st: parmed.structure.Structure\n    idx: List[int] = field(default_factory=list)\n    residues: List = field(default_factory=list)\n    imap: Dict[int,int] = field(default_factory=dict) # pocket atom idx -&gt; st atom idx\n\n    def coor(self) -&gt; np.ndarray:\n        return self.st.coordinates[self.idx,:]\n\n    def centroid(self) -&gt; np.ndarray:\n        return np.mean(self.coor(), axis=0)\n\n    def name(self) -&gt; List[str]:\n        return [self.st.atoms[i].name for i in self.idx ]\n\n    def residue_number(self) -&gt; List[int]:\n        return [self.st.atoms[i].residue.number for i in self.idx ]\n        # return [ r.number for r in self.residues ]\n\n    def residue_name(self) -&gt; List[str]:\n        return [self.st.atoms[i].residue.name for i in self.idx ]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Pocket.idx","title":"<code>idx = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Pocket.imap","title":"<code>imap = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Pocket.residues","title":"<code>residues = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Pocket.st","title":"<code>st</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Pocket.__init__","title":"<code>__init__(st, idx=list(), residues=list(), imap=dict())</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Pocket.centroid","title":"<code>centroid()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def centroid(self) -&gt; np.ndarray:\n    return np.mean(self.coor(), axis=0)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Pocket.coor","title":"<code>coor()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def coor(self) -&gt; np.ndarray:\n    return self.st.coordinates[self.idx,:]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Pocket.name","title":"<code>name()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def name(self) -&gt; List[str]:\n    return [self.st.atoms[i].name for i in self.idx ]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Pocket.residue_name","title":"<code>residue_name()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def residue_name(self) -&gt; List[str]:\n    return [self.st.atoms[i].residue.name for i in self.idx ]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Pocket.residue_number","title":"<code>residue_number()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def residue_number(self) -&gt; List[int]:\n    return [self.st.atoms[i].residue.number for i in self.idx ]\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Reference","title":"<code>Reference</code>  <code>dataclass</code>","text":"<p>Class for reference information.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>@dataclass\nclass Reference:\n    \"\"\"Class for reference information.\"\"\"\n    st: parmed.structure.Structure\n    pocket: Pocket\n    ligand: Ligand\n\n    def coor(self) -&gt; np.ndarray:\n        return self.st.coordinates\n\n    def centroid(self) -&gt; np.ndarray:\n        return np.mean(self.coor(), axis=0)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Reference.ligand","title":"<code>ligand</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Reference.pocket","title":"<code>pocket</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Reference.st","title":"<code>st</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Reference.__init__","title":"<code>__init__(st, pocket, ligand)</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Reference.centroid","title":"<code>centroid()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def centroid(self) -&gt; np.ndarray:\n    return np.mean(self.coor(), axis=0)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Reference.coor","title":"<code>coor()</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def coor(self) -&gt; np.ndarray:\n    return self.st.coordinates\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary","title":"<code>Ternary</code>","text":"<p>Class for ternary complex modeling.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>class Ternary:\n    \"\"\"Class for ternary complex modeling.\"\"\"\n\n    def __init__(self, \n                 st: parmed.structure.Structure,\n                 molecules: Dict,\n                 references: Dict,\n                 ligand_resname: str,\n                 workdir: str | pathlib.Path = '.',\n                ):\n\n        # parmed.struct.Structure objects\n        self.st = st # md system\n        self.imap = {(a.residue.number,a.name) : a.idx for a in st.atoms}\n        self.molecule = {}\n        for k,v in molecules.items():\n            idx = [self.imap[(b.residue.number, b.name)] for b in st[v].atoms]\n            self.molecule[k] = Molecule(st, idx)\n        self.references = references\n        if not isinstance(workdir, pathlib.Path):\n            workdir = pathlib.Path(workdir)\n        workdir.mkdir(parents=True, exist_ok=True)        \n        self.workdir = workdir\n\n        self.map = {}\n        self.map_data = {}\n        self.ligand = {}\n        self.pocket = {}\n        self.ref = {}\n        self.rmsd_ref_coor = np.zeros((len(st.atoms), 3))\n        self.rmsd_idx_group = {}\n        self.centroid = {}\n        # reference coordinates for RMSDForce\n        # should have identical number of coordinates as the self.st\n        # even though all the coordinates are not used\n\n        self.ligand['0'] = self.create_ligand(st, ligand_resname, \"structure-ligand\")\n\n        for k in references:\n            self.map_to_reference(k)\n            self.rmsd_ref_coor[np.array(self.pocket[k].idx),:] = self.ref[k].pocket.coor()\n            self.rmsd_ref_coor[np.array(self.ligand[k].idx),:] = self.ref[k].ligand.coor()\n            self.rmsd_idx_group[k] = np.concatenate((self.pocket[k].idx, self.ligand[k].idx,))\n            self.map[k] = {\n                'ligand': pd.DataFrame(self.map_data[k]['ligand']),\n                'pocket': pd.DataFrame(self.map_data[k]['pocket']),\n            }\n\n\n    def create_ligand(self, st:parmed.structure.Structure, resname:str, prefix:str) -&gt; Ligand:\n        \"\"\"Create a Ligand class object.\n\n        Args:\n            st (parmed.structure.Structure): input structure.\n            resname (str): residue name for ligand.\n            prefix (str): prefix for output pdb file.\n\n        Raises:\n            ValueError: when residue name does not exist.\n\n        Returns:\n            Ligand: object containing ligand information.\n        \"\"\"\n        outfile = (self.workdir / f\"{prefix}-{resname}.pdb\").as_posix()\n        try:\n            idx0 = [atom.idx for atom in st.atoms if (atom.residue.name == resname)]\n            assert len(idx0) &gt; 0\n        except:\n            raise ValueError(f\"{resname} does not exist\")\n        try:\n            # write the ligand to a pdb file which then is read by Chem.MolFromPDBFile to create a rdkit.Chem.Mol\n            # non-hydrogen atoms\n            # Order of atoms in the pdb is same as that of the rdmol\n            indices = []\n            imap = {}\n            pdb_idx = 0\n            for atom in st.atoms:\n                if atom.residue.name == resname and atom.atomic_number &gt; 1:\n                    imap[pdb_idx] = atom.idx\n                    indices.append(atom.idx)\n                    pdb_idx += 1\n            st[f':{resname}&amp;!@H='].save(outfile, overwrite=True)\n            mol = Chem.MolFromPDBFile(outfile)\n            assert mol\n            assert imap\n        except:\n            raise ValueError(f\"cannot create molecule for {resname}\")\n\n        return Ligand(st=st, idx0=idx0, idx=indices, imap=imap, mol=mol)\n\n\n    def create_pocket(self, st:parmed.structure.Structure, resname:str, dist:float, include:str, exclude:str) -&gt; Pocket:\n        \"\"\"Create a Pocket class object.\n\n        Args:\n            st (parmed.structure.Structure): input structure.\n            resname (str): residue name for ligand.\n            dist (float): distance cutoff from ligand which is regarded as pocket.\n            include (str): residue or atom selection to include as pocket.\n            exclude (str): residue or atom selection to exlude from pocket.\n\n        Raises:\n            ValueError: when pocket cannot be defined.\n\n        Returns:\n            Pocket: object containing pocket information.\n        \"\"\"\n        try:\n            # select all `pocket_atom` atoms within `pocket_dist` from the `ref_resname` residues and save to a pdb.\n            # the whole residue is selected if any atom satisfies the distance criteria\n            pocket = st[f\"(:{resname}&lt;:{dist})&amp;(!:{resname})&amp;({include})&amp;!({exclude})\"]\n            imap = {(a.residue.number, a.name) : a.idx for a in st.atoms}\n            indices = [imap[(b.residue.number, b.name)] for b in pocket.atoms]\n            assert len(pocket.residues) &gt; 0\n            assert len(pocket.atoms) &gt; 0\n        except:\n            raise ValueError(\"cannot define reference ligand binding pocket\")\n\n        return Pocket(st=st, idx=indices, residues=pocket.residues, imap=imap)\n\n\n    def create_map_data(self, ref_id:str) -&gt; None:\n        \"\"\"Create a map/dictionary for atom indexes.\n\n        Args:\n            ref_id (str): id for reference.\n        \"\"\"\n        self.map_data[ref_id] = {\n            'ligand' : {\n                'ref_idx': self.ref[ref_id].ligand.idx,\n                'ref_name': self.ref[ref_id].ligand.name(),\n                'ref_atomic_number' : self.ref[ref_id].ligand.atomic_number(), \n                'ref_residue_name' : self.ref[ref_id].ligand.residue_name(),\n                'ref_residue_number' :  self.ref[ref_id].ligand.residue_number(),\n                'idx': self.ligand[ref_id].idx,\n                'name' : self.ligand[ref_id].name(),\n                'atomic_number': self.ligand[ref_id].atomic_number(),\n                'residue_name' : self.ligand[ref_id].residue_name(),\n                'residue_number' : self.ligand[ref_id].residue_number(),\n                },\n            'pocket' : { \n                'ref_idx' : self.ref[ref_id].pocket.idx,\n                'ref_name' : self.ref[ref_id].pocket.name(),\n                'ref_residue_name' : self.ref[ref_id].pocket.residue_name(),\n                'ref_residue_number' : self.ref[ref_id].pocket.residue_number(),\n                'idx' : self.pocket[ref_id].idx,\n                'name' : self.pocket[ref_id].name(),\n                'residue_name' : self.pocket[ref_id].residue_name(),\n                'residue_number' : self.pocket[ref_id].residue_number(),\n            }\n        }\n\n\n    def map_to_reference(self, ref_id: str, quiet:bool=False) -&gt; None:\n        \"\"\"Map structure to the given reference.\n\n        Args:\n            ref_id (str): id of reference structure.\n            quiet (bool, optional): whether to print details. Defaults to False.\n\n        Raises:\n            ValueError: when mapping fails.\n        \"\"\"\n        pdb     = self.references[ref_id][\"pdb\"]\n        resname = self.references[ref_id][\"resname\"]\n        smarts  = self.references[ref_id][\"smarts\"]\n        dist    = self.references[ref_id][\"pocket\"][\"distance\"]\n        include = self.references[ref_id][\"pocket\"][\"include\"]\n        exclude = self.references[ref_id][\"pocket\"][\"exclude\"]\n\n        if not quiet:\n            print(f\"Mapping to {ref_id}...\")\n\n        try:\n            if isinstance(pdb, pathlib.Path):\n                ref_st = parmed.load_file(pdb.as_posix())\n            else:\n                ref_st = parmed.load_file(pdb)\n            assert ref_st\n        except:\n            raise ValueError(f\"cannot load reference pdb file: {pdb}\") \n\n        self.map_data[ref_id] = {'ligand': {}, 'pocket': {}}\n\n        # reference ligand\n        ref_ligand = self.create_ligand(ref_st, resname, \"reference-ligand\")\n\n        success = False\n        for _smarts in smarts:\n            query = Chem.MolFromSmarts(_smarts)\n            if not (self.ligand['0'].mol.HasSubstructMatch(query) and ref_ligand.mol.HasSubstructMatch(query)):\n                continue\n            ligand_match = self.ligand['0'].mol.GetSubstructMatch(query)\n            ref_match = ref_ligand.mol.GetSubstructMatch(query)\n            # GetSubstructMatch() returns the indices of the molecule\u2019s atoms that match a substructure query.\n            # only a single match is returned\n            # the ordering of the indices corresponds to the atom ordering in the query. \n            # For example, the first index is for the atom in this molecule that matches the first atom in the query.\n            # create a ligand substructure that matches with the reference in SMARTS\n            indices = [self.ligand['0'].imap[i] for i in ligand_match]\n            self.ligand[ref_id] = Ligand(self.st, idx=indices, mol=self.ligand['0'].mol, highlight=ligand_match)\n            ref_ligand.idx = [ref_ligand.imap[i] for i in ref_match]\n            ref_ligand.highlight = ref_match\n            success = True\n            break\n        assert success, 'No match found for the reference ligand SMARTS'\n\n        # reference pocket\n        ref_pocket = self.create_pocket(ref_st, resname, dist, include, exclude)\n\n        # create a reference\n        self.ref[ref_id] = Reference(st=ref_st, ligand=ref_ligand, pocket=ref_pocket)\n\n        # mapping structure to the reference\n        # find matching residue numbers and names with reference\n        ref_pocket_residue_numbers = [r.number for r in ref_pocket.residues]\n        ref_pocket_residue_names = [r.name for r in ref_pocket.residues]\n        offset = [ x-ref_pocket_residue_numbers[0] for x in ref_pocket_residue_numbers ]\n        rmap = {} # ref_pocket_residue_number -&gt; st residue.number\n        residues = []\n        for i in range(len(self.st.residues)):\n            if self.st.residues[i].name == ref_pocket_residue_names[0]:\n                found = True\n                for o, n in zip(offset, ref_pocket_residue_names):\n                    st_resname = self.st.residues[i+o].name\n                    if st_resname in ['HIE', 'HID']:\n                        st_resname = 'HIS'\n                    if st_resname != n:\n                        found = False\n                        break\n                if found: # sequence matches\n                    for o, r, n in zip(offset, ref_pocket_residue_numbers, ref_pocket_residue_names):\n                        st_residx = i + o\n                        st_residue_name = self.st.residues[st_residx].name\n                        st_residue_number = self.st.residues[st_residx].number\n                        rmap[r] = st_residue_number\n                        residues.append(self.st.residues[st_residx])\n        try:\n            assert len(rmap) &gt; 0\n        except:\n            print(\"ref_pocket_residue_numbers\", ref_pocket_residue_numbers)\n            print(\"ref_pocket_residue_nanes\", ref_pocket_residue_names)\n            raise ValueError('No match found for the reference pocket.')\n\n        indices = []\n        for i in ref_pocket.idx:\n            ai = ref_pocket.st.atoms[i]\n            matching_residue_number = rmap[ai.residue.number]\n            for aj in self.st.atoms:\n                if aj.residue.number == matching_residue_number and aj.name == ai.name:\n                    indices.append(aj.idx)\n\n        # create a pocket that matches the reference pocket\n        self.pocket[ref_id] = Pocket(self.st, idx=indices, residues=residues)\n\n        try:\n            assert len(self.ligand[ref_id].idx) == len(self.ref[ref_id].ligand.idx)\n            assert len(self.pocket[ref_id].idx) == len(self.ref[ref_id].pocket.idx)\n        except:\n            raise ValueError('Numbers of indices between reference and structure do not match.')\n\n        if not quiet:\n            print(f\"number of ligand atoms: {len(self.ligand[ref_id].idx)}\")\n            print(f\"number of pocket atoms: {len(self.pocket[ref_id].idx)}\")\n\n        self.create_map_data(ref_id)\n\n\n    def molview(self, ref_id:str | None = None, width:int=600, height:int=400) -&gt; None:\n        \"\"\"Depict a ligand with substructure highlights.\n\n        Args:\n            ref_id (str | None, optional): id of reference structure. Defaults to None.\n            width (int, optional): width. Defaults to 600.\n            height (int, optional): height. Defaults to 400.\n        \"\"\"\n        if ref_id is None:\n            highlight = []\n            for k in self.references:\n                highlight.extend(self.ligand[k].highlight)\n            view_svg(self.ligand['0'].mol, highlight=highlight, width=width, height=height)\n        else:\n            view_svg(self.ref[ref_id].ligand.mol, highlight=self.ref[ref_id].ligand.highlight)\n\n\n    def distance(self) -&gt; None:\n        \"\"\"Summary of centroid distances.\n        \"\"\"\n        for k in self.references:\n            self.centroid[k] = {\n                \"ref_pocket\" : self.ref[k].pocket.centroid(),\n                \"ref_ligand\" : self.ref[k].ligand.centroid(),\n                \"pocket\": self.pocket[k].centroid(),\n                \"ligand\": self.ligand[k].centroid(),\n            }\n            print(f\"Centroid({k}):\")\n            for kk, v in self.centroid[k].items():\n                print(f\"    {kk}: {v}\")   \n            dpls = np.linalg.norm(self.centroid[k][\"pocket\"] - self.centroid[k][\"ligand\"])\n            dplr = np.linalg.norm(self.centroid[k][\"ref_pocket\"] - self.centroid[k][\"ref_ligand\"])\n            print(f\"Distance Centroid({k} pocket)-Centroid({k} ligand) {dpls:8.3f} (reference: {dplr:5.3f})\")\n        [k1, k2] = [ k for k in self.references ]\n        dpp = np.linalg.norm(self.centroid[k1][\"pocket\"] - self.centroid[k2][\"pocket\"])\n        dll = np.linalg.norm(self.centroid[k1][\"ligand\"] - self.centroid[k2][\"ligand\"])\n        print(f\"Distance Centroid({k1} pocket)-Centroid({k2} pocket) {dpp:8.3f}\")\n        print(f\"Distance Centroid({k1} ligand)-Centroid({k2} ligand) {dll:8.3f}\")\n\n\n    def rmsd(self) -&gt; None:\n        \"\"\"Summary of RMSD.\"\"\"\n        for k in self.references:\n            indices = self.rmsd_idx_group[k]\n            (_rot, _trans, _centroid, _rmsd) = kabsch_algorithm(self.st.coordinates[indices,:], self.rmsd_ref_coor[indices,:]) \n            print(f\"RMSD ({k} pocket and ligand) {_rmsd:8.3f}\")\n\n\n    def move_ligand_to(self, ref_id:str) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Get transformations to move ligand coordinates to the supposed binding pocket.\n\n        Args:\n            ref_id (str): id of reference structure (pocket).\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: (transformed coordinates, centroid, rotation matrix, translation vector)\n        \"\"\"\n        # 1. align the reference to the structure using the reference pocket\n        # ref_pocket_pos = self.ref_st[ref_id][self.ref_pocket_idx_group[ref_id],:]\n        # pocket_pos = self.st.coordinates[self.pocket_idx_group[ref_id],:]\n        (rot, trans, centroid, rmsd) = kabsch_algorithm(self.ref[ref_id].pocket.coor(), \n                                                        self.pocket[ref_id].coor())\n        # aligned_ref_st_pos = np.dot(self.ref_st[ref_id].coordinates-centroid, rot.T) + centroid + trans\n        aligned_ref = np.dot(self.ref[ref_id].coor() - centroid, rot.T) + centroid + trans\n\n        # 2. align the structure ligand to the reference ligand\n        aligned_ref_ligand_pos = aligned_ref[self.ref[ref_id].ligand.idx,:]\n        # ligand_pos = self.st.coordinates[self.ligand_idx_group[ref_id],:]\n        (rot, trans, centroid, rmsd) = kabsch_algorithm(self.ligand[ref_id].coor(), \n                                                        aligned_ref_ligand_pos)\n        # ligand = self.st.coordinates[self.ligand_indexes,:]\n        # transform whole ligand\n        transformed = np.dot(self.ligand['0'].coor() - centroid, rot.T) + centroid + trans\n        return (transformed, centroid, rot, trans)\n\n\n    def move_molecule_to(self, molecule_id:str, ref_id:str) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Get transformations to move protein coordinates to the supposed ligand.\n\n        Args:\n            molecule_id (str): id of molecule.\n            ref_id (str): id of reference structure(ligand)\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: _description_\n        \"\"\"\n        # 1. align the reference to the structure using the reference ligand\n        # ref_ligand_pos = self.ref_st[ref_id].coordinates[self.ref_ligand_idx_group[ref_id],:]\n        # ligand_pos = self.st.coordinates[self.ligand_idx_group[ref_id],:]\n        (rot, trans, centroid, rmsd) = kabsch_algorithm(self.ref[ref_id].ligand.coor(), \n                                                        self.ligand[ref_id].coor())\n        # aligned_ref_st_pos = np.dot(self.ref_st[ref_id].coordinates-centroid, rot.T) + centroid + trans\n        aligned_ref = np.dot(self.ref[ref_id].coor() - centroid, rot.T) + centroid + trans\n\n        # 2. align the structure pocket to the reference pocket\n        aligned_ref_pocket_pos = aligned_ref[self.ref[ref_id].pocket.idx,:]\n        # pocket_pos = self.st.coordinates[self.pocket_idx_group[ref_id],:]\n        (rot, trans, centroid, rmsd) = kabsch_algorithm(self.pocket[ref_id].coor(), \n                                                        aligned_ref_pocket_pos) \n        transformed = np.dot(self.molecule[molecule_id].coor() -centroid, rot.T) + centroid + trans\n        return (transformed, centroid, rot, trans)\n\n\n    def save_molecule(self, molecule_id:str, path:str | pathlib.Path, overwrite:bool=True) -&gt; None:\n        \"\"\"Save molecular coordinates to an output file.\n\n        Args:\n            molecule_id (str): id of molecule.\n            path (str | pathlib.Path): output file path.\n            overwrite (bool, optional): whether to overwrite. Defaults to True.\n        \"\"\"\n        if isinstance(path, pathlib.Path):\n            path = path.as_posix()\n        st = self.molecule[molecule_id].st\n        st[self.molecule[molecule_id].idx].save(path, overwrite=overwrite)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.centroid","title":"<code>centroid = {}</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.imap","title":"<code>imap = {(a.residue.number, a.name): a.idxfor a in st.atoms}</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.ligand","title":"<code>ligand = {}</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.map","title":"<code>map = {}</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.map_data","title":"<code>map_data = {}</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.molecule","title":"<code>molecule = {}</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.pocket","title":"<code>pocket = {}</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.ref","title":"<code>ref = {}</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.references","title":"<code>references = references</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.rmsd_idx_group","title":"<code>rmsd_idx_group = {}</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.rmsd_ref_coor","title":"<code>rmsd_ref_coor = np.zeros((len(st.atoms), 3))</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.st","title":"<code>st = st</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.workdir","title":"<code>workdir = workdir</code>  <code>instance-attribute</code>","text":""},{"location":"ternary.html#mdscribe.ternary.Ternary.__init__","title":"<code>__init__(st, molecules, references, ligand_resname, workdir='.')</code>","text":"Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def __init__(self, \n             st: parmed.structure.Structure,\n             molecules: Dict,\n             references: Dict,\n             ligand_resname: str,\n             workdir: str | pathlib.Path = '.',\n            ):\n\n    # parmed.struct.Structure objects\n    self.st = st # md system\n    self.imap = {(a.residue.number,a.name) : a.idx for a in st.atoms}\n    self.molecule = {}\n    for k,v in molecules.items():\n        idx = [self.imap[(b.residue.number, b.name)] for b in st[v].atoms]\n        self.molecule[k] = Molecule(st, idx)\n    self.references = references\n    if not isinstance(workdir, pathlib.Path):\n        workdir = pathlib.Path(workdir)\n    workdir.mkdir(parents=True, exist_ok=True)        \n    self.workdir = workdir\n\n    self.map = {}\n    self.map_data = {}\n    self.ligand = {}\n    self.pocket = {}\n    self.ref = {}\n    self.rmsd_ref_coor = np.zeros((len(st.atoms), 3))\n    self.rmsd_idx_group = {}\n    self.centroid = {}\n    # reference coordinates for RMSDForce\n    # should have identical number of coordinates as the self.st\n    # even though all the coordinates are not used\n\n    self.ligand['0'] = self.create_ligand(st, ligand_resname, \"structure-ligand\")\n\n    for k in references:\n        self.map_to_reference(k)\n        self.rmsd_ref_coor[np.array(self.pocket[k].idx),:] = self.ref[k].pocket.coor()\n        self.rmsd_ref_coor[np.array(self.ligand[k].idx),:] = self.ref[k].ligand.coor()\n        self.rmsd_idx_group[k] = np.concatenate((self.pocket[k].idx, self.ligand[k].idx,))\n        self.map[k] = {\n            'ligand': pd.DataFrame(self.map_data[k]['ligand']),\n            'pocket': pd.DataFrame(self.map_data[k]['pocket']),\n        }\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.create_ligand","title":"<code>create_ligand(st, resname, prefix)</code>","text":"<p>Create a Ligand class object.</p> <p>Parameters:</p> Name Type Description Default <code>st</code> <code>Structure</code> <p>input structure.</p> required <code>resname</code> <code>str</code> <p>residue name for ligand.</p> required <code>prefix</code> <code>str</code> <p>prefix for output pdb file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>when residue name does not exist.</p> <p>Returns:</p> Name Type Description <code>Ligand</code> <code>Ligand</code> <p>object containing ligand information.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def create_ligand(self, st:parmed.structure.Structure, resname:str, prefix:str) -&gt; Ligand:\n    \"\"\"Create a Ligand class object.\n\n    Args:\n        st (parmed.structure.Structure): input structure.\n        resname (str): residue name for ligand.\n        prefix (str): prefix for output pdb file.\n\n    Raises:\n        ValueError: when residue name does not exist.\n\n    Returns:\n        Ligand: object containing ligand information.\n    \"\"\"\n    outfile = (self.workdir / f\"{prefix}-{resname}.pdb\").as_posix()\n    try:\n        idx0 = [atom.idx for atom in st.atoms if (atom.residue.name == resname)]\n        assert len(idx0) &gt; 0\n    except:\n        raise ValueError(f\"{resname} does not exist\")\n    try:\n        # write the ligand to a pdb file which then is read by Chem.MolFromPDBFile to create a rdkit.Chem.Mol\n        # non-hydrogen atoms\n        # Order of atoms in the pdb is same as that of the rdmol\n        indices = []\n        imap = {}\n        pdb_idx = 0\n        for atom in st.atoms:\n            if atom.residue.name == resname and atom.atomic_number &gt; 1:\n                imap[pdb_idx] = atom.idx\n                indices.append(atom.idx)\n                pdb_idx += 1\n        st[f':{resname}&amp;!@H='].save(outfile, overwrite=True)\n        mol = Chem.MolFromPDBFile(outfile)\n        assert mol\n        assert imap\n    except:\n        raise ValueError(f\"cannot create molecule for {resname}\")\n\n    return Ligand(st=st, idx0=idx0, idx=indices, imap=imap, mol=mol)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.create_map_data","title":"<code>create_map_data(ref_id)</code>","text":"<p>Create a map/dictionary for atom indexes.</p> <p>Parameters:</p> Name Type Description Default <code>ref_id</code> <code>str</code> <p>id for reference.</p> required Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def create_map_data(self, ref_id:str) -&gt; None:\n    \"\"\"Create a map/dictionary for atom indexes.\n\n    Args:\n        ref_id (str): id for reference.\n    \"\"\"\n    self.map_data[ref_id] = {\n        'ligand' : {\n            'ref_idx': self.ref[ref_id].ligand.idx,\n            'ref_name': self.ref[ref_id].ligand.name(),\n            'ref_atomic_number' : self.ref[ref_id].ligand.atomic_number(), \n            'ref_residue_name' : self.ref[ref_id].ligand.residue_name(),\n            'ref_residue_number' :  self.ref[ref_id].ligand.residue_number(),\n            'idx': self.ligand[ref_id].idx,\n            'name' : self.ligand[ref_id].name(),\n            'atomic_number': self.ligand[ref_id].atomic_number(),\n            'residue_name' : self.ligand[ref_id].residue_name(),\n            'residue_number' : self.ligand[ref_id].residue_number(),\n            },\n        'pocket' : { \n            'ref_idx' : self.ref[ref_id].pocket.idx,\n            'ref_name' : self.ref[ref_id].pocket.name(),\n            'ref_residue_name' : self.ref[ref_id].pocket.residue_name(),\n            'ref_residue_number' : self.ref[ref_id].pocket.residue_number(),\n            'idx' : self.pocket[ref_id].idx,\n            'name' : self.pocket[ref_id].name(),\n            'residue_name' : self.pocket[ref_id].residue_name(),\n            'residue_number' : self.pocket[ref_id].residue_number(),\n        }\n    }\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.create_pocket","title":"<code>create_pocket(st, resname, dist, include, exclude)</code>","text":"<p>Create a Pocket class object.</p> <p>Parameters:</p> Name Type Description Default <code>st</code> <code>Structure</code> <p>input structure.</p> required <code>resname</code> <code>str</code> <p>residue name for ligand.</p> required <code>dist</code> <code>float</code> <p>distance cutoff from ligand which is regarded as pocket.</p> required <code>include</code> <code>str</code> <p>residue or atom selection to include as pocket.</p> required <code>exclude</code> <code>str</code> <p>residue or atom selection to exlude from pocket.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>when pocket cannot be defined.</p> <p>Returns:</p> Name Type Description <code>Pocket</code> <code>Pocket</code> <p>object containing pocket information.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def create_pocket(self, st:parmed.structure.Structure, resname:str, dist:float, include:str, exclude:str) -&gt; Pocket:\n    \"\"\"Create a Pocket class object.\n\n    Args:\n        st (parmed.structure.Structure): input structure.\n        resname (str): residue name for ligand.\n        dist (float): distance cutoff from ligand which is regarded as pocket.\n        include (str): residue or atom selection to include as pocket.\n        exclude (str): residue or atom selection to exlude from pocket.\n\n    Raises:\n        ValueError: when pocket cannot be defined.\n\n    Returns:\n        Pocket: object containing pocket information.\n    \"\"\"\n    try:\n        # select all `pocket_atom` atoms within `pocket_dist` from the `ref_resname` residues and save to a pdb.\n        # the whole residue is selected if any atom satisfies the distance criteria\n        pocket = st[f\"(:{resname}&lt;:{dist})&amp;(!:{resname})&amp;({include})&amp;!({exclude})\"]\n        imap = {(a.residue.number, a.name) : a.idx for a in st.atoms}\n        indices = [imap[(b.residue.number, b.name)] for b in pocket.atoms]\n        assert len(pocket.residues) &gt; 0\n        assert len(pocket.atoms) &gt; 0\n    except:\n        raise ValueError(\"cannot define reference ligand binding pocket\")\n\n    return Pocket(st=st, idx=indices, residues=pocket.residues, imap=imap)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.distance","title":"<code>distance()</code>","text":"<p>Summary of centroid distances.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def distance(self) -&gt; None:\n    \"\"\"Summary of centroid distances.\n    \"\"\"\n    for k in self.references:\n        self.centroid[k] = {\n            \"ref_pocket\" : self.ref[k].pocket.centroid(),\n            \"ref_ligand\" : self.ref[k].ligand.centroid(),\n            \"pocket\": self.pocket[k].centroid(),\n            \"ligand\": self.ligand[k].centroid(),\n        }\n        print(f\"Centroid({k}):\")\n        for kk, v in self.centroid[k].items():\n            print(f\"    {kk}: {v}\")   \n        dpls = np.linalg.norm(self.centroid[k][\"pocket\"] - self.centroid[k][\"ligand\"])\n        dplr = np.linalg.norm(self.centroid[k][\"ref_pocket\"] - self.centroid[k][\"ref_ligand\"])\n        print(f\"Distance Centroid({k} pocket)-Centroid({k} ligand) {dpls:8.3f} (reference: {dplr:5.3f})\")\n    [k1, k2] = [ k for k in self.references ]\n    dpp = np.linalg.norm(self.centroid[k1][\"pocket\"] - self.centroid[k2][\"pocket\"])\n    dll = np.linalg.norm(self.centroid[k1][\"ligand\"] - self.centroid[k2][\"ligand\"])\n    print(f\"Distance Centroid({k1} pocket)-Centroid({k2} pocket) {dpp:8.3f}\")\n    print(f\"Distance Centroid({k1} ligand)-Centroid({k2} ligand) {dll:8.3f}\")\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.map_to_reference","title":"<code>map_to_reference(ref_id, quiet=False)</code>","text":"<p>Map structure to the given reference.</p> <p>Parameters:</p> Name Type Description Default <code>ref_id</code> <code>str</code> <p>id of reference structure.</p> required <code>quiet</code> <code>bool</code> <p>whether to print details. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>when mapping fails.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def map_to_reference(self, ref_id: str, quiet:bool=False) -&gt; None:\n    \"\"\"Map structure to the given reference.\n\n    Args:\n        ref_id (str): id of reference structure.\n        quiet (bool, optional): whether to print details. Defaults to False.\n\n    Raises:\n        ValueError: when mapping fails.\n    \"\"\"\n    pdb     = self.references[ref_id][\"pdb\"]\n    resname = self.references[ref_id][\"resname\"]\n    smarts  = self.references[ref_id][\"smarts\"]\n    dist    = self.references[ref_id][\"pocket\"][\"distance\"]\n    include = self.references[ref_id][\"pocket\"][\"include\"]\n    exclude = self.references[ref_id][\"pocket\"][\"exclude\"]\n\n    if not quiet:\n        print(f\"Mapping to {ref_id}...\")\n\n    try:\n        if isinstance(pdb, pathlib.Path):\n            ref_st = parmed.load_file(pdb.as_posix())\n        else:\n            ref_st = parmed.load_file(pdb)\n        assert ref_st\n    except:\n        raise ValueError(f\"cannot load reference pdb file: {pdb}\") \n\n    self.map_data[ref_id] = {'ligand': {}, 'pocket': {}}\n\n    # reference ligand\n    ref_ligand = self.create_ligand(ref_st, resname, \"reference-ligand\")\n\n    success = False\n    for _smarts in smarts:\n        query = Chem.MolFromSmarts(_smarts)\n        if not (self.ligand['0'].mol.HasSubstructMatch(query) and ref_ligand.mol.HasSubstructMatch(query)):\n            continue\n        ligand_match = self.ligand['0'].mol.GetSubstructMatch(query)\n        ref_match = ref_ligand.mol.GetSubstructMatch(query)\n        # GetSubstructMatch() returns the indices of the molecule\u2019s atoms that match a substructure query.\n        # only a single match is returned\n        # the ordering of the indices corresponds to the atom ordering in the query. \n        # For example, the first index is for the atom in this molecule that matches the first atom in the query.\n        # create a ligand substructure that matches with the reference in SMARTS\n        indices = [self.ligand['0'].imap[i] for i in ligand_match]\n        self.ligand[ref_id] = Ligand(self.st, idx=indices, mol=self.ligand['0'].mol, highlight=ligand_match)\n        ref_ligand.idx = [ref_ligand.imap[i] for i in ref_match]\n        ref_ligand.highlight = ref_match\n        success = True\n        break\n    assert success, 'No match found for the reference ligand SMARTS'\n\n    # reference pocket\n    ref_pocket = self.create_pocket(ref_st, resname, dist, include, exclude)\n\n    # create a reference\n    self.ref[ref_id] = Reference(st=ref_st, ligand=ref_ligand, pocket=ref_pocket)\n\n    # mapping structure to the reference\n    # find matching residue numbers and names with reference\n    ref_pocket_residue_numbers = [r.number for r in ref_pocket.residues]\n    ref_pocket_residue_names = [r.name for r in ref_pocket.residues]\n    offset = [ x-ref_pocket_residue_numbers[0] for x in ref_pocket_residue_numbers ]\n    rmap = {} # ref_pocket_residue_number -&gt; st residue.number\n    residues = []\n    for i in range(len(self.st.residues)):\n        if self.st.residues[i].name == ref_pocket_residue_names[0]:\n            found = True\n            for o, n in zip(offset, ref_pocket_residue_names):\n                st_resname = self.st.residues[i+o].name\n                if st_resname in ['HIE', 'HID']:\n                    st_resname = 'HIS'\n                if st_resname != n:\n                    found = False\n                    break\n            if found: # sequence matches\n                for o, r, n in zip(offset, ref_pocket_residue_numbers, ref_pocket_residue_names):\n                    st_residx = i + o\n                    st_residue_name = self.st.residues[st_residx].name\n                    st_residue_number = self.st.residues[st_residx].number\n                    rmap[r] = st_residue_number\n                    residues.append(self.st.residues[st_residx])\n    try:\n        assert len(rmap) &gt; 0\n    except:\n        print(\"ref_pocket_residue_numbers\", ref_pocket_residue_numbers)\n        print(\"ref_pocket_residue_nanes\", ref_pocket_residue_names)\n        raise ValueError('No match found for the reference pocket.')\n\n    indices = []\n    for i in ref_pocket.idx:\n        ai = ref_pocket.st.atoms[i]\n        matching_residue_number = rmap[ai.residue.number]\n        for aj in self.st.atoms:\n            if aj.residue.number == matching_residue_number and aj.name == ai.name:\n                indices.append(aj.idx)\n\n    # create a pocket that matches the reference pocket\n    self.pocket[ref_id] = Pocket(self.st, idx=indices, residues=residues)\n\n    try:\n        assert len(self.ligand[ref_id].idx) == len(self.ref[ref_id].ligand.idx)\n        assert len(self.pocket[ref_id].idx) == len(self.ref[ref_id].pocket.idx)\n    except:\n        raise ValueError('Numbers of indices between reference and structure do not match.')\n\n    if not quiet:\n        print(f\"number of ligand atoms: {len(self.ligand[ref_id].idx)}\")\n        print(f\"number of pocket atoms: {len(self.pocket[ref_id].idx)}\")\n\n    self.create_map_data(ref_id)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.molview","title":"<code>molview(ref_id=None, width=600, height=400)</code>","text":"<p>Depict a ligand with substructure highlights.</p> <p>Parameters:</p> Name Type Description Default <code>ref_id</code> <code>str | None</code> <p>id of reference structure. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>width. Defaults to 600.</p> <code>600</code> <code>height</code> <code>int</code> <p>height. Defaults to 400.</p> <code>400</code> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def molview(self, ref_id:str | None = None, width:int=600, height:int=400) -&gt; None:\n    \"\"\"Depict a ligand with substructure highlights.\n\n    Args:\n        ref_id (str | None, optional): id of reference structure. Defaults to None.\n        width (int, optional): width. Defaults to 600.\n        height (int, optional): height. Defaults to 400.\n    \"\"\"\n    if ref_id is None:\n        highlight = []\n        for k in self.references:\n            highlight.extend(self.ligand[k].highlight)\n        view_svg(self.ligand['0'].mol, highlight=highlight, width=width, height=height)\n    else:\n        view_svg(self.ref[ref_id].ligand.mol, highlight=self.ref[ref_id].ligand.highlight)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.move_ligand_to","title":"<code>move_ligand_to(ref_id)</code>","text":"<p>Get transformations to move ligand coordinates to the supposed binding pocket.</p> <p>Parameters:</p> Name Type Description Default <code>ref_id</code> <code>str</code> <p>id of reference structure (pocket).</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: (transformed coordinates, centroid, rotation matrix, translation vector)</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def move_ligand_to(self, ref_id:str) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Get transformations to move ligand coordinates to the supposed binding pocket.\n\n    Args:\n        ref_id (str): id of reference structure (pocket).\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: (transformed coordinates, centroid, rotation matrix, translation vector)\n    \"\"\"\n    # 1. align the reference to the structure using the reference pocket\n    # ref_pocket_pos = self.ref_st[ref_id][self.ref_pocket_idx_group[ref_id],:]\n    # pocket_pos = self.st.coordinates[self.pocket_idx_group[ref_id],:]\n    (rot, trans, centroid, rmsd) = kabsch_algorithm(self.ref[ref_id].pocket.coor(), \n                                                    self.pocket[ref_id].coor())\n    # aligned_ref_st_pos = np.dot(self.ref_st[ref_id].coordinates-centroid, rot.T) + centroid + trans\n    aligned_ref = np.dot(self.ref[ref_id].coor() - centroid, rot.T) + centroid + trans\n\n    # 2. align the structure ligand to the reference ligand\n    aligned_ref_ligand_pos = aligned_ref[self.ref[ref_id].ligand.idx,:]\n    # ligand_pos = self.st.coordinates[self.ligand_idx_group[ref_id],:]\n    (rot, trans, centroid, rmsd) = kabsch_algorithm(self.ligand[ref_id].coor(), \n                                                    aligned_ref_ligand_pos)\n    # ligand = self.st.coordinates[self.ligand_indexes,:]\n    # transform whole ligand\n    transformed = np.dot(self.ligand['0'].coor() - centroid, rot.T) + centroid + trans\n    return (transformed, centroid, rot, trans)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.move_molecule_to","title":"<code>move_molecule_to(molecule_id, ref_id)</code>","text":"<p>Get transformations to move protein coordinates to the supposed ligand.</p> <p>Parameters:</p> Name Type Description Default <code>molecule_id</code> <code>str</code> <p>id of molecule.</p> required <code>ref_id</code> <code>str</code> <p>id of reference structure(ligand)</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: description</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def move_molecule_to(self, molecule_id:str, ref_id:str) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Get transformations to move protein coordinates to the supposed ligand.\n\n    Args:\n        molecule_id (str): id of molecule.\n        ref_id (str): id of reference structure(ligand)\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: _description_\n    \"\"\"\n    # 1. align the reference to the structure using the reference ligand\n    # ref_ligand_pos = self.ref_st[ref_id].coordinates[self.ref_ligand_idx_group[ref_id],:]\n    # ligand_pos = self.st.coordinates[self.ligand_idx_group[ref_id],:]\n    (rot, trans, centroid, rmsd) = kabsch_algorithm(self.ref[ref_id].ligand.coor(), \n                                                    self.ligand[ref_id].coor())\n    # aligned_ref_st_pos = np.dot(self.ref_st[ref_id].coordinates-centroid, rot.T) + centroid + trans\n    aligned_ref = np.dot(self.ref[ref_id].coor() - centroid, rot.T) + centroid + trans\n\n    # 2. align the structure pocket to the reference pocket\n    aligned_ref_pocket_pos = aligned_ref[self.ref[ref_id].pocket.idx,:]\n    # pocket_pos = self.st.coordinates[self.pocket_idx_group[ref_id],:]\n    (rot, trans, centroid, rmsd) = kabsch_algorithm(self.pocket[ref_id].coor(), \n                                                    aligned_ref_pocket_pos) \n    transformed = np.dot(self.molecule[molecule_id].coor() -centroid, rot.T) + centroid + trans\n    return (transformed, centroid, rot, trans)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.rmsd","title":"<code>rmsd()</code>","text":"<p>Summary of RMSD.</p> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def rmsd(self) -&gt; None:\n    \"\"\"Summary of RMSD.\"\"\"\n    for k in self.references:\n        indices = self.rmsd_idx_group[k]\n        (_rot, _trans, _centroid, _rmsd) = kabsch_algorithm(self.st.coordinates[indices,:], self.rmsd_ref_coor[indices,:]) \n        print(f\"RMSD ({k} pocket and ligand) {_rmsd:8.3f}\")\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.Ternary.save_molecule","title":"<code>save_molecule(molecule_id, path, overwrite=True)</code>","text":"<p>Save molecular coordinates to an output file.</p> <p>Parameters:</p> Name Type Description Default <code>molecule_id</code> <code>str</code> <p>id of molecule.</p> required <code>path</code> <code>str | Path</code> <p>output file path.</p> required <code>overwrite</code> <code>bool</code> <p>whether to overwrite. Defaults to True.</p> <code>True</code> Source code in <code>mdscribe/ternary/complex.py</code> <pre><code>def save_molecule(self, molecule_id:str, path:str | pathlib.Path, overwrite:bool=True) -&gt; None:\n    \"\"\"Save molecular coordinates to an output file.\n\n    Args:\n        molecule_id (str): id of molecule.\n        path (str | pathlib.Path): output file path.\n        overwrite (bool, optional): whether to overwrite. Defaults to True.\n    \"\"\"\n    if isinstance(path, pathlib.Path):\n        path = path.as_posix()\n    st = self.molecule[molecule_id].st\n    st[self.molecule[molecule_id].idx].save(path, overwrite=overwrite)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.kabsch_algorithm","title":"<code>kabsch_algorithm(P, Q)</code>","text":"<p>Computes the optimal rotation and translation to align two sets of points (P -&gt; Q), and their RMSD.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; P = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]])\n&gt;&gt;&gt; Q = np.array([[1, 1, 0], [2, 1, 0], [1, 2, 0]])\n&gt;&gt;&gt; # Q is translated by (1,1,0) \n&gt;&gt;&gt; (rot, trans, rmsd) = kabsch_transform(P, Q)\n&gt;&gt;&gt; transform(P, rot, trans)\n</code></pre> <pre><code>&gt;&gt;&gt; P = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n&gt;&gt;&gt; Q = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n&gt;&gt;&gt; # Q is a 90-degree rotation of P around the z-axis\n&gt;&gt;&gt; (rot, trans, rmsd) = kabsch_transform(P, Q)\n&gt;&gt;&gt; transform(P, rot, trans)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>ndarray</code> <p>subject coordinates. Not modified.</p> required <code>Q</code> <code>ndarray</code> <p>target coordinates. Not modified.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray, float]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray, float]: A tuple containing the optimal rotation matrix, the optimal translation vector, the centroid of P, and the RMSD.</p> Source code in <code>mdscribe/helper/coord.py</code> <pre><code>def kabsch_algorithm(P:np.ndarray, Q:np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, float]:\n    \"\"\"Computes the optimal rotation and translation to align two sets of points (P -&gt; Q),\n    and their RMSD.\n\n    Examples:\n        &gt;&gt;&gt; P = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]])\n        &gt;&gt;&gt; Q = np.array([[1, 1, 0], [2, 1, 0], [1, 2, 0]])\n        &gt;&gt;&gt; # Q is translated by (1,1,0) \n        &gt;&gt;&gt; (rot, trans, rmsd) = kabsch_transform(P, Q)\n        &gt;&gt;&gt; transform(P, rot, trans)\n\n        &gt;&gt;&gt; P = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        &gt;&gt;&gt; Q = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n        &gt;&gt;&gt; # Q is a 90-degree rotation of P around the z-axis\n        &gt;&gt;&gt; (rot, trans, rmsd) = kabsch_transform(P, Q)\n        &gt;&gt;&gt; transform(P, rot, trans)\n\n    Args:\n        P (np.ndarray): subject coordinates. Not modified.\n        Q (np.ndarray): target coordinates. Not modified.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, float]: A tuple containing the optimal rotation matrix, the optimal\n            translation vector, the centroid of P, and the RMSD.\n    \"\"\"\n\n    assert P.shape == Q.shape, \"Matrix dimensions must match\"\n\n    # Compute centroids\n    centroid_P = np.mean(P, axis=0)\n    centroid_Q = np.mean(Q, axis=0)\n\n    # Optimal translation\n    t = centroid_Q - centroid_P\n\n    # Center the points\n    p = P - centroid_P\n    q = Q - centroid_Q\n\n    # Compute the covariance matrix\n    H = np.dot(p.T, q)\n\n    # SVD\n    U, S, Vt = np.linalg.svd(H)\n    V = Vt.T\n    d = np.linalg.det(np.dot(V, U.T))\n    e = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, d]])\n\n    # Optimal rotation\n    R = np.dot(np.dot(V, e), U.T)\n\n    # RMSD\n    rmsd = np.sqrt(np.sum(np.square(np.dot(p, R.T) - q)) / P.shape[0])\n\n    return (R, t, centroid_P, rmsd)\n</code></pre>"},{"location":"ternary.html#mdscribe.ternary.view_svg","title":"<code>view_svg(rdmol, highlight=[], width=300, height=300)</code>","text":"<p>SVG depiction for the Jupyter Notebook.</p> Reference <p>https://www.linkedin.com/pulse/using-rdkit-jupyter-notebooks-lee-davies/</p> <p>Parameters:</p> Name Type Description Default <code>rdmol</code> <code>Mol</code> <p>rdkit molecule.</p> required <code>highlight</code> <code>list</code> <p>highlighted atom indexes. Defaults to [].</p> <code>[]</code> <code>width</code> <code>int</code> <p>width. Defaults to 300.</p> <code>300</code> <code>height</code> <code>int</code> <p>height. Defaults to 300.</p> <code>300</code> Source code in <code>mdscribe/helper/svg.py</code> <pre><code>def view_svg(rdmol:Chem.Mol, highlight=[], width=300, height=300):\n    \"\"\"SVG depiction for the Jupyter Notebook.\n\n    Reference:\n        https://www.linkedin.com/pulse/using-rdkit-jupyter-notebooks-lee-davies/\n\n    Args:\n        rdmol (Chem.Mol): rdkit molecule.\n        highlight (list, optional): highlighted atom indexes. Defaults to [].\n        width (int, optional): width. Defaults to 300.\n        height (int, optional): height. Defaults to 300.\n    \"\"\"\n    rdmol2d = Chem.Mol(rdmol)\n    AllChem.Compute2DCoords(rdmol2d)\n    drawer = rdMolDraw2D.MolDraw2DSVG(width, height)\n    drawer.DrawMolecule(rdmol2d, highlightAtoms=highlight)\n    drawer.FinishDrawing()\n    svg = drawer.GetDrawingText()\n    display(SVG(svg.replace(\"svg:\",\"\")))\n</code></pre>"}]}